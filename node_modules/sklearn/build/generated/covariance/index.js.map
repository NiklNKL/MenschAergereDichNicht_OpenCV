{"version":3,"sources":["../../../src/generated/covariance/EmpiricalCovariance.ts","../../../src/generated/covariance/EllipticEnvelope.ts","../../../src/generated/covariance/GraphicalLasso.ts","../../../src/generated/covariance/GraphicalLassoCV.ts","../../../src/generated/covariance/LedoitWolf.ts","../../../src/generated/covariance/MinCovDet.ts","../../../src/generated/covariance/OAS.ts","../../../src/generated/covariance/ShrunkCovariance.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Maximum likelihood covariance estimator.\n\n  @see https://scikit-learn.org/stable/modules/generated/sklearn.covariance.EmpiricalCovariance.html\n */\nexport class EmpiricalCovariance {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: EmpiricalCovarianceOptions) {\n    this.id = `EmpiricalCovariance${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EmpiricalCovariance instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'EmpiricalCovariance.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.covariance import EmpiricalCovariance\ntry: bridgeEmpiricalCovariance\nexcept NameError: bridgeEmpiricalCovariance = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_EmpiricalCovariance = {'store_precision': ${\n      this.opts['store_precision'] ?? undefined\n    }, 'assume_centered': ${this.opts['assume_centered'] ?? undefined}}\n\nctor_EmpiricalCovariance = {k: v for k, v in ctor_EmpiricalCovariance.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeEmpiricalCovariance[${this.id}] = EmpiricalCovariance(**ctor_EmpiricalCovariance)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeEmpiricalCovariance[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Compute the Mean Squared Error between two covariance estimators.\n   */\n  async error_norm(opts: EmpiricalCovarianceErrorNormOptions): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EmpiricalCovariance instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'EmpiricalCovariance must call init() before error_norm()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_EmpiricalCovariance_error_norm = {'comp_cov': np.array(${\n      opts['comp_cov'] ?? undefined\n    }) if ${opts['comp_cov'] !== undefined} else None, 'norm': ${\n      opts['norm'] ?? undefined\n    }, 'scaling': ${opts['scaling'] ?? undefined}, 'squared': ${\n      opts['squared'] ?? undefined\n    }}\n\npms_EmpiricalCovariance_error_norm = {k: v for k, v in pms_EmpiricalCovariance_error_norm.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_EmpiricalCovariance_error_norm = bridgeEmpiricalCovariance[${this.id}].error_norm(**pms_EmpiricalCovariance_error_norm)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_EmpiricalCovariance_error_norm.tolist() if hasattr(res_EmpiricalCovariance_error_norm, 'tolist') else res_EmpiricalCovariance_error_norm`\n  }\n\n  /**\n    Fit the maximum likelihood covariance estimator to X.\n   */\n  async fit(opts: EmpiricalCovarianceFitOptions): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EmpiricalCovariance instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('EmpiricalCovariance must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_EmpiricalCovariance_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_EmpiricalCovariance_fit = {k: v for k, v in pms_EmpiricalCovariance_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_EmpiricalCovariance_fit = bridgeEmpiricalCovariance[${this.id}].fit(**pms_EmpiricalCovariance_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_EmpiricalCovariance_fit.tolist() if hasattr(res_EmpiricalCovariance_fit, 'tolist') else res_EmpiricalCovariance_fit`\n  }\n\n  /**\n    Getter for the precision matrix.\n   */\n  async get_precision(\n    opts: EmpiricalCovarianceGetPrecisionOptions\n  ): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EmpiricalCovariance instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'EmpiricalCovariance must call init() before get_precision()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_EmpiricalCovariance_get_precision = {'precision_': np.array(${\n      opts['precision_'] ?? undefined\n    }) if ${opts['precision_'] !== undefined} else None}\n\npms_EmpiricalCovariance_get_precision = {k: v for k, v in pms_EmpiricalCovariance_get_precision.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_EmpiricalCovariance_get_precision = bridgeEmpiricalCovariance[${this.id}].get_precision(**pms_EmpiricalCovariance_get_precision)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_EmpiricalCovariance_get_precision.tolist() if hasattr(res_EmpiricalCovariance_get_precision, 'tolist') else res_EmpiricalCovariance_get_precision`\n  }\n\n  /**\n    Compute the squared Mahalanobis distances of given observations.\n   */\n  async mahalanobis(\n    opts: EmpiricalCovarianceMahalanobisOptions\n  ): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EmpiricalCovariance instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'EmpiricalCovariance must call init() before mahalanobis()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_EmpiricalCovariance_mahalanobis = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_EmpiricalCovariance_mahalanobis = {k: v for k, v in pms_EmpiricalCovariance_mahalanobis.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_EmpiricalCovariance_mahalanobis = bridgeEmpiricalCovariance[${this.id}].mahalanobis(**pms_EmpiricalCovariance_mahalanobis)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_EmpiricalCovariance_mahalanobis.tolist() if hasattr(res_EmpiricalCovariance_mahalanobis, 'tolist') else res_EmpiricalCovariance_mahalanobis`\n  }\n\n  /**\n    Compute the log-likelihood of X_test under the estimated Gaussian model.\n\n    The Gaussian model is defined by its mean and covariance matrix which are represented respectively by self.location_ and self.covariance_.\n   */\n  async score(opts: EmpiricalCovarianceScoreOptions): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EmpiricalCovariance instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('EmpiricalCovariance must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_EmpiricalCovariance_score = {'X_test': np.array(${\n      opts['X_test'] ?? undefined\n    }) if ${opts['X_test'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }}\n\npms_EmpiricalCovariance_score = {k: v for k, v in pms_EmpiricalCovariance_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_EmpiricalCovariance_score = bridgeEmpiricalCovariance[${this.id}].score(**pms_EmpiricalCovariance_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_EmpiricalCovariance_score.tolist() if hasattr(res_EmpiricalCovariance_score, 'tolist') else res_EmpiricalCovariance_score`\n  }\n\n  /**\n    Estimated location, i.e. the estimated mean.\n   */\n  get location_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EmpiricalCovariance instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'EmpiricalCovariance must call init() before accessing location_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_EmpiricalCovariance_location_ = bridgeEmpiricalCovariance[${this.id}].location_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_EmpiricalCovariance_location_.tolist() if hasattr(attr_EmpiricalCovariance_location_, 'tolist') else attr_EmpiricalCovariance_location_`\n    })()\n  }\n\n  /**\n    Estimated covariance matrix\n   */\n  get covariance_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EmpiricalCovariance instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'EmpiricalCovariance must call init() before accessing covariance_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_EmpiricalCovariance_covariance_ = bridgeEmpiricalCovariance[${this.id}].covariance_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_EmpiricalCovariance_covariance_.tolist() if hasattr(attr_EmpiricalCovariance_covariance_, 'tolist') else attr_EmpiricalCovariance_covariance_`\n    })()\n  }\n\n  /**\n    Estimated pseudo-inverse matrix. (stored only if store_precision is True)\n   */\n  get precision_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EmpiricalCovariance instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'EmpiricalCovariance must call init() before accessing precision_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_EmpiricalCovariance_precision_ = bridgeEmpiricalCovariance[${this.id}].precision_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_EmpiricalCovariance_precision_.tolist() if hasattr(attr_EmpiricalCovariance_precision_, 'tolist') else attr_EmpiricalCovariance_precision_`\n    })()\n  }\n\n  /**\n    Number of features seen during fit.\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EmpiricalCovariance instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'EmpiricalCovariance must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_EmpiricalCovariance_n_features_in_ = bridgeEmpiricalCovariance[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_EmpiricalCovariance_n_features_in_.tolist() if hasattr(attr_EmpiricalCovariance_n_features_in_, 'tolist') else attr_EmpiricalCovariance_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during fit. Defined only when X has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EmpiricalCovariance instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'EmpiricalCovariance must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_EmpiricalCovariance_feature_names_in_ = bridgeEmpiricalCovariance[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_EmpiricalCovariance_feature_names_in_.tolist() if hasattr(attr_EmpiricalCovariance_feature_names_in_, 'tolist') else attr_EmpiricalCovariance_feature_names_in_`\n    })()\n  }\n}\n\nexport interface EmpiricalCovarianceOptions {\n  /**\n    Specifies if the estimated precision is stored.\n\n    @defaultValue `true`\n   */\n  store_precision?: boolean\n\n  /**\n    If True, data are not centered before computation. Useful when working with data whose mean is almost, but not exactly zero. If False (default), data are centered before computation.\n\n    @defaultValue `false`\n   */\n  assume_centered?: boolean\n}\n\nexport interface EmpiricalCovarianceErrorNormOptions {\n  /**\n    The covariance to compare with.\n   */\n  comp_cov?: ArrayLike[]\n\n  /**\n    The type of norm used to compute the error. Available error types: - ‘frobenius’ (default): sqrt(tr(A^t.A)) - ‘spectral’: sqrt(max(eigenvalues(A^t.A)) where A is the error (comp_cov - self.covariance_).\n\n    @defaultValue `'frobenius'`\n   */\n  norm?: 'frobenius' | 'spectral'\n\n  /**\n    If True (default), the squared error norm is divided by n_features. If False, the squared error norm is not rescaled.\n\n    @defaultValue `true`\n   */\n  scaling?: boolean\n\n  /**\n    Whether to compute the squared error norm or the error norm. If True (default), the squared error norm is returned. If False, the error norm is returned.\n\n    @defaultValue `true`\n   */\n  squared?: boolean\n}\n\nexport interface EmpiricalCovarianceFitOptions {\n  /**\n    Training data, where n_samples is the number of samples and n_features is the number of features.\n   */\n  X?: ArrayLike[]\n\n  /**\n    Not used, present for API consistency by convention.\n   */\n  y?: any\n}\n\nexport interface EmpiricalCovarianceGetPrecisionOptions {\n  /**\n    The precision matrix associated to the current covariance object.\n   */\n  precision_?: ArrayLike[]\n}\n\nexport interface EmpiricalCovarianceMahalanobisOptions {\n  /**\n    The observations, the Mahalanobis distances of the which we compute. Observations are assumed to be drawn from the same distribution than the data used in fit.\n   */\n  X?: ArrayLike[]\n}\n\nexport interface EmpiricalCovarianceScoreOptions {\n  /**\n    Test data of which we compute the likelihood, where n_samples is the number of samples and n_features is the number of features. X_test is assumed to be drawn from the same distribution than the data used in fit (including centering).\n   */\n  X_test?: ArrayLike[]\n\n  /**\n    Not used, present for API consistency by convention.\n   */\n  y?: any\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  An object for detecting outliers in a Gaussian distributed dataset.\n\n  @see https://scikit-learn.org/stable/modules/generated/sklearn.covariance.EllipticEnvelope.html\n */\nexport class EllipticEnvelope {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: EllipticEnvelopeOptions) {\n    this.id = `EllipticEnvelope${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EllipticEnvelope instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('EllipticEnvelope.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.covariance import EllipticEnvelope\ntry: bridgeEllipticEnvelope\nexcept NameError: bridgeEllipticEnvelope = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_EllipticEnvelope = {'store_precision': ${\n      this.opts['store_precision'] ?? undefined\n    }, 'assume_centered': ${\n      this.opts['assume_centered'] ?? undefined\n    }, 'support_fraction': ${\n      this.opts['support_fraction'] ?? undefined\n    }, 'contamination': ${\n      this.opts['contamination'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}}\n\nctor_EllipticEnvelope = {k: v for k, v in ctor_EllipticEnvelope.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeEllipticEnvelope[${this.id}] = EllipticEnvelope(**ctor_EllipticEnvelope)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeEllipticEnvelope[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Apply a correction to raw Minimum Covariance Determinant estimates.\n\n    Correction using the empirical correction factor suggested by Rousseeuw and Van Driessen in [RVD].\n   */\n  async correct_covariance(\n    opts: EllipticEnvelopeCorrectCovarianceOptions\n  ): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EllipticEnvelope instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'EllipticEnvelope must call init() before correct_covariance()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_EllipticEnvelope_correct_covariance = {'data': np.array(${\n      opts['data'] ?? undefined\n    }) if ${opts['data'] !== undefined} else None}\n\npms_EllipticEnvelope_correct_covariance = {k: v for k, v in pms_EllipticEnvelope_correct_covariance.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_EllipticEnvelope_correct_covariance = bridgeEllipticEnvelope[${this.id}].correct_covariance(**pms_EllipticEnvelope_correct_covariance)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_EllipticEnvelope_correct_covariance.tolist() if hasattr(res_EllipticEnvelope_correct_covariance, 'tolist') else res_EllipticEnvelope_correct_covariance`\n  }\n\n  /**\n    Compute the decision function of the given observations.\n   */\n  async decision_function(\n    opts: EllipticEnvelopeDecisionFunctionOptions\n  ): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EllipticEnvelope instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'EllipticEnvelope must call init() before decision_function()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_EllipticEnvelope_decision_function = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_EllipticEnvelope_decision_function = {k: v for k, v in pms_EllipticEnvelope_decision_function.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_EllipticEnvelope_decision_function = bridgeEllipticEnvelope[${this.id}].decision_function(**pms_EllipticEnvelope_decision_function)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_EllipticEnvelope_decision_function.tolist() if hasattr(res_EllipticEnvelope_decision_function, 'tolist') else res_EllipticEnvelope_decision_function`\n  }\n\n  /**\n    Compute the Mean Squared Error between two covariance estimators.\n   */\n  async error_norm(opts: EllipticEnvelopeErrorNormOptions): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EllipticEnvelope instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('EllipticEnvelope must call init() before error_norm()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_EllipticEnvelope_error_norm = {'comp_cov': np.array(${\n      opts['comp_cov'] ?? undefined\n    }) if ${opts['comp_cov'] !== undefined} else None, 'norm': ${\n      opts['norm'] ?? undefined\n    }, 'scaling': ${opts['scaling'] ?? undefined}, 'squared': ${\n      opts['squared'] ?? undefined\n    }}\n\npms_EllipticEnvelope_error_norm = {k: v for k, v in pms_EllipticEnvelope_error_norm.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_EllipticEnvelope_error_norm = bridgeEllipticEnvelope[${this.id}].error_norm(**pms_EllipticEnvelope_error_norm)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_EllipticEnvelope_error_norm.tolist() if hasattr(res_EllipticEnvelope_error_norm, 'tolist') else res_EllipticEnvelope_error_norm`\n  }\n\n  /**\n    Fit the EllipticEnvelope model.\n   */\n  async fit(opts: EllipticEnvelopeFitOptions): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EllipticEnvelope instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('EllipticEnvelope must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_EllipticEnvelope_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_EllipticEnvelope_fit = {k: v for k, v in pms_EllipticEnvelope_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_EllipticEnvelope_fit = bridgeEllipticEnvelope[${this.id}].fit(**pms_EllipticEnvelope_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_EllipticEnvelope_fit.tolist() if hasattr(res_EllipticEnvelope_fit, 'tolist') else res_EllipticEnvelope_fit`\n  }\n\n  /**\n    Perform fit on X and returns labels for X.\n\n    Returns -1 for outliers and 1 for inliers.\n   */\n  async fit_predict(opts: EllipticEnvelopeFitPredictOptions): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EllipticEnvelope instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('EllipticEnvelope must call init() before fit_predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_EllipticEnvelope_fit_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_EllipticEnvelope_fit_predict = {k: v for k, v in pms_EllipticEnvelope_fit_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_EllipticEnvelope_fit_predict = bridgeEllipticEnvelope[${this.id}].fit_predict(**pms_EllipticEnvelope_fit_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_EllipticEnvelope_fit_predict.tolist() if hasattr(res_EllipticEnvelope_fit_predict, 'tolist') else res_EllipticEnvelope_fit_predict`\n  }\n\n  /**\n    Getter for the precision matrix.\n   */\n  async get_precision(opts: EllipticEnvelopeGetPrecisionOptions): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EllipticEnvelope instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'EllipticEnvelope must call init() before get_precision()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_EllipticEnvelope_get_precision = {'precision_': np.array(${\n      opts['precision_'] ?? undefined\n    }) if ${opts['precision_'] !== undefined} else None}\n\npms_EllipticEnvelope_get_precision = {k: v for k, v in pms_EllipticEnvelope_get_precision.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_EllipticEnvelope_get_precision = bridgeEllipticEnvelope[${this.id}].get_precision(**pms_EllipticEnvelope_get_precision)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_EllipticEnvelope_get_precision.tolist() if hasattr(res_EllipticEnvelope_get_precision, 'tolist') else res_EllipticEnvelope_get_precision`\n  }\n\n  /**\n    Compute the squared Mahalanobis distances of given observations.\n   */\n  async mahalanobis(\n    opts: EllipticEnvelopeMahalanobisOptions\n  ): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EllipticEnvelope instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('EllipticEnvelope must call init() before mahalanobis()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_EllipticEnvelope_mahalanobis = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_EllipticEnvelope_mahalanobis = {k: v for k, v in pms_EllipticEnvelope_mahalanobis.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_EllipticEnvelope_mahalanobis = bridgeEllipticEnvelope[${this.id}].mahalanobis(**pms_EllipticEnvelope_mahalanobis)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_EllipticEnvelope_mahalanobis.tolist() if hasattr(res_EllipticEnvelope_mahalanobis, 'tolist') else res_EllipticEnvelope_mahalanobis`\n  }\n\n  /**\n    Predict labels (1 inlier, -1 outlier) of X according to fitted model.\n   */\n  async predict(opts: EllipticEnvelopePredictOptions): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EllipticEnvelope instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('EllipticEnvelope must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_EllipticEnvelope_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_EllipticEnvelope_predict = {k: v for k, v in pms_EllipticEnvelope_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_EllipticEnvelope_predict = bridgeEllipticEnvelope[${this.id}].predict(**pms_EllipticEnvelope_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_EllipticEnvelope_predict.tolist() if hasattr(res_EllipticEnvelope_predict, 'tolist') else res_EllipticEnvelope_predict`\n  }\n\n  /**\n    Re-weight raw Minimum Covariance Determinant estimates.\n\n    Re-weight observations using Rousseeuw’s method (equivalent to deleting outlying observations from the data set before computing location and covariance estimates) described in [RVDriessen].\n   */\n  async reweight_covariance(\n    opts: EllipticEnvelopeReweightCovarianceOptions\n  ): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EllipticEnvelope instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'EllipticEnvelope must call init() before reweight_covariance()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_EllipticEnvelope_reweight_covariance = {'data': np.array(${\n      opts['data'] ?? undefined\n    }) if ${opts['data'] !== undefined} else None}\n\npms_EllipticEnvelope_reweight_covariance = {k: v for k, v in pms_EllipticEnvelope_reweight_covariance.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_EllipticEnvelope_reweight_covariance = bridgeEllipticEnvelope[${this.id}].reweight_covariance(**pms_EllipticEnvelope_reweight_covariance)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_EllipticEnvelope_reweight_covariance.tolist() if hasattr(res_EllipticEnvelope_reweight_covariance, 'tolist') else res_EllipticEnvelope_reweight_covariance`\n  }\n\n  /**\n    Return the mean accuracy on the given test data and labels.\n\n    In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.\n   */\n  async score(opts: EllipticEnvelopeScoreOptions): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EllipticEnvelope instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('EllipticEnvelope must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_EllipticEnvelope_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_EllipticEnvelope_score = {k: v for k, v in pms_EllipticEnvelope_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_EllipticEnvelope_score = bridgeEllipticEnvelope[${this.id}].score(**pms_EllipticEnvelope_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_EllipticEnvelope_score.tolist() if hasattr(res_EllipticEnvelope_score, 'tolist') else res_EllipticEnvelope_score`\n  }\n\n  /**\n    Compute the negative Mahalanobis distances.\n   */\n  async score_samples(\n    opts: EllipticEnvelopeScoreSamplesOptions\n  ): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EllipticEnvelope instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'EllipticEnvelope must call init() before score_samples()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_EllipticEnvelope_score_samples = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_EllipticEnvelope_score_samples = {k: v for k, v in pms_EllipticEnvelope_score_samples.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_EllipticEnvelope_score_samples = bridgeEllipticEnvelope[${this.id}].score_samples(**pms_EllipticEnvelope_score_samples)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_EllipticEnvelope_score_samples.tolist() if hasattr(res_EllipticEnvelope_score_samples, 'tolist') else res_EllipticEnvelope_score_samples`\n  }\n\n  /**\n    Estimated robust location.\n   */\n  get location_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EllipticEnvelope instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'EllipticEnvelope must call init() before accessing location_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_EllipticEnvelope_location_ = bridgeEllipticEnvelope[${this.id}].location_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_EllipticEnvelope_location_.tolist() if hasattr(attr_EllipticEnvelope_location_, 'tolist') else attr_EllipticEnvelope_location_`\n    })()\n  }\n\n  /**\n    Estimated robust covariance matrix.\n   */\n  get covariance_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EllipticEnvelope instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'EllipticEnvelope must call init() before accessing covariance_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_EllipticEnvelope_covariance_ = bridgeEllipticEnvelope[${this.id}].covariance_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_EllipticEnvelope_covariance_.tolist() if hasattr(attr_EllipticEnvelope_covariance_, 'tolist') else attr_EllipticEnvelope_covariance_`\n    })()\n  }\n\n  /**\n    Estimated pseudo inverse matrix. (stored only if store_precision is True)\n   */\n  get precision_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EllipticEnvelope instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'EllipticEnvelope must call init() before accessing precision_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_EllipticEnvelope_precision_ = bridgeEllipticEnvelope[${this.id}].precision_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_EllipticEnvelope_precision_.tolist() if hasattr(attr_EllipticEnvelope_precision_, 'tolist') else attr_EllipticEnvelope_precision_`\n    })()\n  }\n\n  /**\n    A mask of the observations that have been used to compute the robust estimates of location and shape.\n   */\n  get support_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EllipticEnvelope instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'EllipticEnvelope must call init() before accessing support_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_EllipticEnvelope_support_ = bridgeEllipticEnvelope[${this.id}].support_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_EllipticEnvelope_support_.tolist() if hasattr(attr_EllipticEnvelope_support_, 'tolist') else attr_EllipticEnvelope_support_`\n    })()\n  }\n\n  /**\n    Offset used to define the decision function from the raw scores. We have the relation: decision_function = score_samples - offset_. The offset depends on the contamination parameter and is defined in such a way we obtain the expected number of outliers (samples with decision function < 0) in training.\n   */\n  get offset_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EllipticEnvelope instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'EllipticEnvelope must call init() before accessing offset_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_EllipticEnvelope_offset_ = bridgeEllipticEnvelope[${this.id}].offset_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_EllipticEnvelope_offset_.tolist() if hasattr(attr_EllipticEnvelope_offset_, 'tolist') else attr_EllipticEnvelope_offset_`\n    })()\n  }\n\n  /**\n    The raw robust estimated location before correction and re-weighting.\n   */\n  get raw_location_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EllipticEnvelope instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'EllipticEnvelope must call init() before accessing raw_location_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_EllipticEnvelope_raw_location_ = bridgeEllipticEnvelope[${this.id}].raw_location_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_EllipticEnvelope_raw_location_.tolist() if hasattr(attr_EllipticEnvelope_raw_location_, 'tolist') else attr_EllipticEnvelope_raw_location_`\n    })()\n  }\n\n  /**\n    The raw robust estimated covariance before correction and re-weighting.\n   */\n  get raw_covariance_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EllipticEnvelope instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'EllipticEnvelope must call init() before accessing raw_covariance_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_EllipticEnvelope_raw_covariance_ = bridgeEllipticEnvelope[${this.id}].raw_covariance_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_EllipticEnvelope_raw_covariance_.tolist() if hasattr(attr_EllipticEnvelope_raw_covariance_, 'tolist') else attr_EllipticEnvelope_raw_covariance_`\n    })()\n  }\n\n  /**\n    A mask of the observations that have been used to compute the raw robust estimates of location and shape, before correction and re-weighting.\n   */\n  get raw_support_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EllipticEnvelope instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'EllipticEnvelope must call init() before accessing raw_support_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_EllipticEnvelope_raw_support_ = bridgeEllipticEnvelope[${this.id}].raw_support_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_EllipticEnvelope_raw_support_.tolist() if hasattr(attr_EllipticEnvelope_raw_support_, 'tolist') else attr_EllipticEnvelope_raw_support_`\n    })()\n  }\n\n  /**\n    Mahalanobis distances of the training set (on which fit is called) observations.\n   */\n  get dist_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EllipticEnvelope instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'EllipticEnvelope must call init() before accessing dist_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_EllipticEnvelope_dist_ = bridgeEllipticEnvelope[${this.id}].dist_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_EllipticEnvelope_dist_.tolist() if hasattr(attr_EllipticEnvelope_dist_, 'tolist') else attr_EllipticEnvelope_dist_`\n    })()\n  }\n\n  /**\n    Number of features seen during fit.\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EllipticEnvelope instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'EllipticEnvelope must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_EllipticEnvelope_n_features_in_ = bridgeEllipticEnvelope[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_EllipticEnvelope_n_features_in_.tolist() if hasattr(attr_EllipticEnvelope_n_features_in_, 'tolist') else attr_EllipticEnvelope_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during fit. Defined only when X has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This EllipticEnvelope instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'EllipticEnvelope must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_EllipticEnvelope_feature_names_in_ = bridgeEllipticEnvelope[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_EllipticEnvelope_feature_names_in_.tolist() if hasattr(attr_EllipticEnvelope_feature_names_in_, 'tolist') else attr_EllipticEnvelope_feature_names_in_`\n    })()\n  }\n}\n\nexport interface EllipticEnvelopeOptions {\n  /**\n    Specify if the estimated precision is stored.\n\n    @defaultValue `true`\n   */\n  store_precision?: boolean\n\n  /**\n    If True, the support of robust location and covariance estimates is computed, and a covariance estimate is recomputed from it, without centering the data. Useful to work with data whose mean is significantly equal to zero but is not exactly zero. If False, the robust location and covariance are directly computed with the FastMCD algorithm without additional treatment.\n\n    @defaultValue `false`\n   */\n  assume_centered?: boolean\n\n  /**\n    The proportion of points to be included in the support of the raw MCD estimate. If None, the minimum value of support_fraction will be used within the algorithm: [n_sample + n_features + 1] / 2. Range is (0, 1).\n   */\n  support_fraction?: number\n\n  /**\n    The amount of contamination of the data set, i.e. the proportion of outliers in the data set. Range is (0, 0.5].\n\n    @defaultValue `0.1`\n   */\n  contamination?: number\n\n  /**\n    Determines the pseudo random number generator for shuffling the data. Pass an int for reproducible results across multiple function calls. See Glossary.\n   */\n  random_state?: number\n}\n\nexport interface EllipticEnvelopeCorrectCovarianceOptions {\n  /**\n    The data matrix, with p features and n samples. The data set must be the one which was used to compute the raw estimates.\n   */\n  data?: ArrayLike[]\n}\n\nexport interface EllipticEnvelopeDecisionFunctionOptions {\n  /**\n    The data matrix.\n   */\n  X?: ArrayLike[]\n}\n\nexport interface EllipticEnvelopeErrorNormOptions {\n  /**\n    The covariance to compare with.\n   */\n  comp_cov?: ArrayLike[]\n\n  /**\n    The type of norm used to compute the error. Available error types: - ‘frobenius’ (default): sqrt(tr(A^t.A)) - ‘spectral’: sqrt(max(eigenvalues(A^t.A)) where A is the error (comp_cov - self.covariance_).\n\n    @defaultValue `'frobenius'`\n   */\n  norm?: 'frobenius' | 'spectral'\n\n  /**\n    If True (default), the squared error norm is divided by n_features. If False, the squared error norm is not rescaled.\n\n    @defaultValue `true`\n   */\n  scaling?: boolean\n\n  /**\n    Whether to compute the squared error norm or the error norm. If True (default), the squared error norm is returned. If False, the error norm is returned.\n\n    @defaultValue `true`\n   */\n  squared?: boolean\n}\n\nexport interface EllipticEnvelopeFitOptions {\n  /**\n    Training data.\n   */\n  X?: ArrayLike[]\n\n  /**\n    Not used, present for API consistency by convention.\n   */\n  y?: any\n}\n\nexport interface EllipticEnvelopeFitPredictOptions {\n  /**\n    The input samples.\n   */\n  X?: ArrayLike | SparseMatrix[]\n\n  /**\n    Not used, present for API consistency by convention.\n   */\n  y?: any\n}\n\nexport interface EllipticEnvelopeGetPrecisionOptions {\n  /**\n    The precision matrix associated to the current covariance object.\n   */\n  precision_?: ArrayLike[]\n}\n\nexport interface EllipticEnvelopeMahalanobisOptions {\n  /**\n    The observations, the Mahalanobis distances of the which we compute. Observations are assumed to be drawn from the same distribution than the data used in fit.\n   */\n  X?: ArrayLike[]\n}\n\nexport interface EllipticEnvelopePredictOptions {\n  /**\n    The data matrix.\n   */\n  X?: ArrayLike[]\n}\n\nexport interface EllipticEnvelopeReweightCovarianceOptions {\n  /**\n    The data matrix, with p features and n samples. The data set must be the one which was used to compute the raw estimates.\n   */\n  data?: ArrayLike[]\n}\n\nexport interface EllipticEnvelopeScoreOptions {\n  /**\n    Test samples.\n   */\n  X?: ArrayLike[]\n\n  /**\n    True labels for X.\n   */\n  y?: ArrayLike\n\n  /**\n    Sample weights.\n   */\n  sample_weight?: ArrayLike\n}\n\nexport interface EllipticEnvelopeScoreSamplesOptions {\n  /**\n    The data matrix.\n   */\n  X?: ArrayLike[]\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Sparse inverse covariance estimation with an l1-penalized estimator.\n\n  @see https://scikit-learn.org/stable/modules/generated/sklearn.covariance.GraphicalLasso.html\n */\nexport class GraphicalLasso {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: GraphicalLassoOptions) {\n    this.id = `GraphicalLasso${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This GraphicalLasso instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('GraphicalLasso.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.covariance import GraphicalLasso\ntry: bridgeGraphicalLasso\nexcept NameError: bridgeGraphicalLasso = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_GraphicalLasso = {'alpha': ${\n      this.opts['alpha'] ?? undefined\n    }, 'mode': ${this.opts['mode'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'enet_tol': ${this.opts['enet_tol'] ?? undefined}, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}, 'assume_centered': ${\n      this.opts['assume_centered'] ?? undefined\n    }}\n\nctor_GraphicalLasso = {k: v for k, v in ctor_GraphicalLasso.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeGraphicalLasso[${this.id}] = GraphicalLasso(**ctor_GraphicalLasso)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeGraphicalLasso[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Compute the Mean Squared Error between two covariance estimators.\n   */\n  async error_norm(opts: GraphicalLassoErrorNormOptions): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This GraphicalLasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('GraphicalLasso must call init() before error_norm()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_GraphicalLasso_error_norm = {'comp_cov': np.array(${\n      opts['comp_cov'] ?? undefined\n    }) if ${opts['comp_cov'] !== undefined} else None, 'norm': ${\n      opts['norm'] ?? undefined\n    }, 'scaling': ${opts['scaling'] ?? undefined}, 'squared': ${\n      opts['squared'] ?? undefined\n    }}\n\npms_GraphicalLasso_error_norm = {k: v for k, v in pms_GraphicalLasso_error_norm.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_GraphicalLasso_error_norm = bridgeGraphicalLasso[${this.id}].error_norm(**pms_GraphicalLasso_error_norm)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_GraphicalLasso_error_norm.tolist() if hasattr(res_GraphicalLasso_error_norm, 'tolist') else res_GraphicalLasso_error_norm`\n  }\n\n  /**\n    Fit the GraphicalLasso model to X.\n   */\n  async fit(opts: GraphicalLassoFitOptions): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This GraphicalLasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('GraphicalLasso must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_GraphicalLasso_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_GraphicalLasso_fit = {k: v for k, v in pms_GraphicalLasso_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_GraphicalLasso_fit = bridgeGraphicalLasso[${this.id}].fit(**pms_GraphicalLasso_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_GraphicalLasso_fit.tolist() if hasattr(res_GraphicalLasso_fit, 'tolist') else res_GraphicalLasso_fit`\n  }\n\n  /**\n    Getter for the precision matrix.\n   */\n  async get_precision(opts: GraphicalLassoGetPrecisionOptions): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This GraphicalLasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('GraphicalLasso must call init() before get_precision()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_GraphicalLasso_get_precision = {'precision_': np.array(${\n      opts['precision_'] ?? undefined\n    }) if ${opts['precision_'] !== undefined} else None}\n\npms_GraphicalLasso_get_precision = {k: v for k, v in pms_GraphicalLasso_get_precision.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_GraphicalLasso_get_precision = bridgeGraphicalLasso[${this.id}].get_precision(**pms_GraphicalLasso_get_precision)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_GraphicalLasso_get_precision.tolist() if hasattr(res_GraphicalLasso_get_precision, 'tolist') else res_GraphicalLasso_get_precision`\n  }\n\n  /**\n    Compute the squared Mahalanobis distances of given observations.\n   */\n  async mahalanobis(opts: GraphicalLassoMahalanobisOptions): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This GraphicalLasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('GraphicalLasso must call init() before mahalanobis()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_GraphicalLasso_mahalanobis = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_GraphicalLasso_mahalanobis = {k: v for k, v in pms_GraphicalLasso_mahalanobis.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_GraphicalLasso_mahalanobis = bridgeGraphicalLasso[${this.id}].mahalanobis(**pms_GraphicalLasso_mahalanobis)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_GraphicalLasso_mahalanobis.tolist() if hasattr(res_GraphicalLasso_mahalanobis, 'tolist') else res_GraphicalLasso_mahalanobis`\n  }\n\n  /**\n    Compute the log-likelihood of X_test under the estimated Gaussian model.\n\n    The Gaussian model is defined by its mean and covariance matrix which are represented respectively by self.location_ and self.covariance_.\n   */\n  async score(opts: GraphicalLassoScoreOptions): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This GraphicalLasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('GraphicalLasso must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_GraphicalLasso_score = {'X_test': np.array(${\n      opts['X_test'] ?? undefined\n    }) if ${opts['X_test'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }}\n\npms_GraphicalLasso_score = {k: v for k, v in pms_GraphicalLasso_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_GraphicalLasso_score = bridgeGraphicalLasso[${this.id}].score(**pms_GraphicalLasso_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_GraphicalLasso_score.tolist() if hasattr(res_GraphicalLasso_score, 'tolist') else res_GraphicalLasso_score`\n  }\n\n  /**\n    Estimated location, i.e. the estimated mean.\n   */\n  get location_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This GraphicalLasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GraphicalLasso must call init() before accessing location_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_GraphicalLasso_location_ = bridgeGraphicalLasso[${this.id}].location_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_GraphicalLasso_location_.tolist() if hasattr(attr_GraphicalLasso_location_, 'tolist') else attr_GraphicalLasso_location_`\n    })()\n  }\n\n  /**\n    Estimated covariance matrix\n   */\n  get covariance_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This GraphicalLasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GraphicalLasso must call init() before accessing covariance_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_GraphicalLasso_covariance_ = bridgeGraphicalLasso[${this.id}].covariance_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_GraphicalLasso_covariance_.tolist() if hasattr(attr_GraphicalLasso_covariance_, 'tolist') else attr_GraphicalLasso_covariance_`\n    })()\n  }\n\n  /**\n    Estimated pseudo inverse matrix.\n   */\n  get precision_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This GraphicalLasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GraphicalLasso must call init() before accessing precision_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_GraphicalLasso_precision_ = bridgeGraphicalLasso[${this.id}].precision_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_GraphicalLasso_precision_.tolist() if hasattr(attr_GraphicalLasso_precision_, 'tolist') else attr_GraphicalLasso_precision_`\n    })()\n  }\n\n  /**\n    Number of iterations run.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This GraphicalLasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GraphicalLasso must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_GraphicalLasso_n_iter_ = bridgeGraphicalLasso[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_GraphicalLasso_n_iter_.tolist() if hasattr(attr_GraphicalLasso_n_iter_, 'tolist') else attr_GraphicalLasso_n_iter_`\n    })()\n  }\n\n  /**\n    Number of features seen during fit.\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This GraphicalLasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GraphicalLasso must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_GraphicalLasso_n_features_in_ = bridgeGraphicalLasso[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_GraphicalLasso_n_features_in_.tolist() if hasattr(attr_GraphicalLasso_n_features_in_, 'tolist') else attr_GraphicalLasso_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during fit. Defined only when X has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This GraphicalLasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GraphicalLasso must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_GraphicalLasso_feature_names_in_ = bridgeGraphicalLasso[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_GraphicalLasso_feature_names_in_.tolist() if hasattr(attr_GraphicalLasso_feature_names_in_, 'tolist') else attr_GraphicalLasso_feature_names_in_`\n    })()\n  }\n}\n\nexport interface GraphicalLassoOptions {\n  /**\n    The regularization parameter: the higher alpha, the more regularization, the sparser the inverse covariance. Range is (0, inf].\n\n    @defaultValue `0.01`\n   */\n  alpha?: number\n\n  /**\n    The Lasso solver to use: coordinate descent or LARS. Use LARS for very sparse underlying graphs, where p > n. Elsewhere prefer cd which is more numerically stable.\n\n    @defaultValue `'cd'`\n   */\n  mode?: 'cd' | 'lars'\n\n  /**\n    The tolerance to declare convergence: if the dual gap goes below this value, iterations are stopped. Range is (0, inf].\n\n    @defaultValue `0.0001`\n   */\n  tol?: number\n\n  /**\n    The tolerance for the elastic net solver used to calculate the descent direction. This parameter controls the accuracy of the search direction for a given column update, not of the overall parameter estimate. Only used for mode=’cd’. Range is (0, inf].\n\n    @defaultValue `0.0001`\n   */\n  enet_tol?: number\n\n  /**\n    The maximum number of iterations.\n\n    @defaultValue `100`\n   */\n  max_iter?: number\n\n  /**\n    If verbose is True, the objective function and dual gap are plotted at each iteration.\n\n    @defaultValue `false`\n   */\n  verbose?: boolean\n\n  /**\n    If True, data are not centered before computation. Useful when working with data whose mean is almost, but not exactly zero. If False, data are centered before computation.\n\n    @defaultValue `false`\n   */\n  assume_centered?: boolean\n}\n\nexport interface GraphicalLassoErrorNormOptions {\n  /**\n    The covariance to compare with.\n   */\n  comp_cov?: ArrayLike[]\n\n  /**\n    The type of norm used to compute the error. Available error types: - ‘frobenius’ (default): sqrt(tr(A^t.A)) - ‘spectral’: sqrt(max(eigenvalues(A^t.A)) where A is the error (comp_cov - self.covariance_).\n\n    @defaultValue `'frobenius'`\n   */\n  norm?: 'frobenius' | 'spectral'\n\n  /**\n    If True (default), the squared error norm is divided by n_features. If False, the squared error norm is not rescaled.\n\n    @defaultValue `true`\n   */\n  scaling?: boolean\n\n  /**\n    Whether to compute the squared error norm or the error norm. If True (default), the squared error norm is returned. If False, the error norm is returned.\n\n    @defaultValue `true`\n   */\n  squared?: boolean\n}\n\nexport interface GraphicalLassoFitOptions {\n  /**\n    Data from which to compute the covariance estimate.\n   */\n  X?: ArrayLike[]\n\n  /**\n    Not used, present for API consistency by convention.\n   */\n  y?: any\n}\n\nexport interface GraphicalLassoGetPrecisionOptions {\n  /**\n    The precision matrix associated to the current covariance object.\n   */\n  precision_?: ArrayLike[]\n}\n\nexport interface GraphicalLassoMahalanobisOptions {\n  /**\n    The observations, the Mahalanobis distances of the which we compute. Observations are assumed to be drawn from the same distribution than the data used in fit.\n   */\n  X?: ArrayLike[]\n}\n\nexport interface GraphicalLassoScoreOptions {\n  /**\n    Test data of which we compute the likelihood, where n_samples is the number of samples and n_features is the number of features. X_test is assumed to be drawn from the same distribution than the data used in fit (including centering).\n   */\n  X_test?: ArrayLike[]\n\n  /**\n    Not used, present for API consistency by convention.\n   */\n  y?: any\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Sparse inverse covariance w/ cross-validated choice of the l1 penalty.\n\n  See glossary entry for cross-validation estimator.\n\n  @see https://scikit-learn.org/stable/modules/generated/sklearn.covariance.GraphicalLassoCV.html\n */\nexport class GraphicalLassoCV {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: GraphicalLassoCVOptions) {\n    this.id = `GraphicalLassoCV${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GraphicalLassoCV instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('GraphicalLassoCV.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.covariance import GraphicalLassoCV\ntry: bridgeGraphicalLassoCV\nexcept NameError: bridgeGraphicalLassoCV = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_GraphicalLassoCV = {'alphas': np.array(${\n      this.opts['alphas'] ?? undefined\n    }) if ${this.opts['alphas'] !== undefined} else None, 'n_refinements': ${\n      this.opts['n_refinements'] ?? undefined\n    }, 'cv': ${this.opts['cv'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'enet_tol': ${this.opts['enet_tol'] ?? undefined}, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'mode': ${this.opts['mode'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}, 'assume_centered': ${\n      this.opts['assume_centered'] ?? undefined\n    }}\n\nctor_GraphicalLassoCV = {k: v for k, v in ctor_GraphicalLassoCV.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeGraphicalLassoCV[${this.id}] = GraphicalLassoCV(**ctor_GraphicalLassoCV)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeGraphicalLassoCV[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Compute the Mean Squared Error between two covariance estimators.\n   */\n  async error_norm(opts: GraphicalLassoCVErrorNormOptions): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GraphicalLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('GraphicalLassoCV must call init() before error_norm()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_GraphicalLassoCV_error_norm = {'comp_cov': np.array(${\n      opts['comp_cov'] ?? undefined\n    }) if ${opts['comp_cov'] !== undefined} else None, 'norm': ${\n      opts['norm'] ?? undefined\n    }, 'scaling': ${opts['scaling'] ?? undefined}, 'squared': ${\n      opts['squared'] ?? undefined\n    }}\n\npms_GraphicalLassoCV_error_norm = {k: v for k, v in pms_GraphicalLassoCV_error_norm.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_GraphicalLassoCV_error_norm = bridgeGraphicalLassoCV[${this.id}].error_norm(**pms_GraphicalLassoCV_error_norm)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_GraphicalLassoCV_error_norm.tolist() if hasattr(res_GraphicalLassoCV_error_norm, 'tolist') else res_GraphicalLassoCV_error_norm`\n  }\n\n  /**\n    Fit the GraphicalLasso covariance model to X.\n   */\n  async fit(opts: GraphicalLassoCVFitOptions): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GraphicalLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('GraphicalLassoCV must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_GraphicalLassoCV_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_GraphicalLassoCV_fit = {k: v for k, v in pms_GraphicalLassoCV_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_GraphicalLassoCV_fit = bridgeGraphicalLassoCV[${this.id}].fit(**pms_GraphicalLassoCV_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_GraphicalLassoCV_fit.tolist() if hasattr(res_GraphicalLassoCV_fit, 'tolist') else res_GraphicalLassoCV_fit`\n  }\n\n  /**\n    Getter for the precision matrix.\n   */\n  async get_precision(opts: GraphicalLassoCVGetPrecisionOptions): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GraphicalLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GraphicalLassoCV must call init() before get_precision()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_GraphicalLassoCV_get_precision = {'precision_': np.array(${\n      opts['precision_'] ?? undefined\n    }) if ${opts['precision_'] !== undefined} else None}\n\npms_GraphicalLassoCV_get_precision = {k: v for k, v in pms_GraphicalLassoCV_get_precision.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_GraphicalLassoCV_get_precision = bridgeGraphicalLassoCV[${this.id}].get_precision(**pms_GraphicalLassoCV_get_precision)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_GraphicalLassoCV_get_precision.tolist() if hasattr(res_GraphicalLassoCV_get_precision, 'tolist') else res_GraphicalLassoCV_get_precision`\n  }\n\n  /**\n    Compute the squared Mahalanobis distances of given observations.\n   */\n  async mahalanobis(\n    opts: GraphicalLassoCVMahalanobisOptions\n  ): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GraphicalLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('GraphicalLassoCV must call init() before mahalanobis()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_GraphicalLassoCV_mahalanobis = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_GraphicalLassoCV_mahalanobis = {k: v for k, v in pms_GraphicalLassoCV_mahalanobis.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_GraphicalLassoCV_mahalanobis = bridgeGraphicalLassoCV[${this.id}].mahalanobis(**pms_GraphicalLassoCV_mahalanobis)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_GraphicalLassoCV_mahalanobis.tolist() if hasattr(res_GraphicalLassoCV_mahalanobis, 'tolist') else res_GraphicalLassoCV_mahalanobis`\n  }\n\n  /**\n    Compute the log-likelihood of X_test under the estimated Gaussian model.\n\n    The Gaussian model is defined by its mean and covariance matrix which are represented respectively by self.location_ and self.covariance_.\n   */\n  async score(opts: GraphicalLassoCVScoreOptions): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GraphicalLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('GraphicalLassoCV must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_GraphicalLassoCV_score = {'X_test': np.array(${\n      opts['X_test'] ?? undefined\n    }) if ${opts['X_test'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }}\n\npms_GraphicalLassoCV_score = {k: v for k, v in pms_GraphicalLassoCV_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_GraphicalLassoCV_score = bridgeGraphicalLassoCV[${this.id}].score(**pms_GraphicalLassoCV_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_GraphicalLassoCV_score.tolist() if hasattr(res_GraphicalLassoCV_score, 'tolist') else res_GraphicalLassoCV_score`\n  }\n\n  /**\n    Estimated location, i.e. the estimated mean.\n   */\n  get location_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GraphicalLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GraphicalLassoCV must call init() before accessing location_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_GraphicalLassoCV_location_ = bridgeGraphicalLassoCV[${this.id}].location_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_GraphicalLassoCV_location_.tolist() if hasattr(attr_GraphicalLassoCV_location_, 'tolist') else attr_GraphicalLassoCV_location_`\n    })()\n  }\n\n  /**\n    Estimated covariance matrix.\n   */\n  get covariance_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GraphicalLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GraphicalLassoCV must call init() before accessing covariance_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_GraphicalLassoCV_covariance_ = bridgeGraphicalLassoCV[${this.id}].covariance_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_GraphicalLassoCV_covariance_.tolist() if hasattr(attr_GraphicalLassoCV_covariance_, 'tolist') else attr_GraphicalLassoCV_covariance_`\n    })()\n  }\n\n  /**\n    Estimated precision matrix (inverse covariance).\n   */\n  get precision_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GraphicalLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GraphicalLassoCV must call init() before accessing precision_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_GraphicalLassoCV_precision_ = bridgeGraphicalLassoCV[${this.id}].precision_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_GraphicalLassoCV_precision_.tolist() if hasattr(attr_GraphicalLassoCV_precision_, 'tolist') else attr_GraphicalLassoCV_precision_`\n    })()\n  }\n\n  /**\n    Penalization parameter selected.\n   */\n  get alpha_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GraphicalLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GraphicalLassoCV must call init() before accessing alpha_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_GraphicalLassoCV_alpha_ = bridgeGraphicalLassoCV[${this.id}].alpha_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_GraphicalLassoCV_alpha_.tolist() if hasattr(attr_GraphicalLassoCV_alpha_, 'tolist') else attr_GraphicalLassoCV_alpha_`\n    })()\n  }\n\n  /**\n    A dict with keys:\n   */\n  get cv_results_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GraphicalLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GraphicalLassoCV must call init() before accessing cv_results_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_GraphicalLassoCV_cv_results_ = bridgeGraphicalLassoCV[${this.id}].cv_results_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_GraphicalLassoCV_cv_results_.tolist() if hasattr(attr_GraphicalLassoCV_cv_results_, 'tolist') else attr_GraphicalLassoCV_cv_results_`\n    })()\n  }\n\n  /**\n    Number of iterations run for the optimal alpha.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GraphicalLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GraphicalLassoCV must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_GraphicalLassoCV_n_iter_ = bridgeGraphicalLassoCV[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_GraphicalLassoCV_n_iter_.tolist() if hasattr(attr_GraphicalLassoCV_n_iter_, 'tolist') else attr_GraphicalLassoCV_n_iter_`\n    })()\n  }\n\n  /**\n    Number of features seen during fit.\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GraphicalLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GraphicalLassoCV must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_GraphicalLassoCV_n_features_in_ = bridgeGraphicalLassoCV[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_GraphicalLassoCV_n_features_in_.tolist() if hasattr(attr_GraphicalLassoCV_n_features_in_, 'tolist') else attr_GraphicalLassoCV_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during fit. Defined only when X has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GraphicalLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GraphicalLassoCV must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_GraphicalLassoCV_feature_names_in_ = bridgeGraphicalLassoCV[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_GraphicalLassoCV_feature_names_in_.tolist() if hasattr(attr_GraphicalLassoCV_feature_names_in_, 'tolist') else attr_GraphicalLassoCV_feature_names_in_`\n    })()\n  }\n}\n\nexport interface GraphicalLassoCVOptions {\n  /**\n    If an integer is given, it fixes the number of points on the grids of alpha to be used. If a list is given, it gives the grid to be used. See the notes in the class docstring for more details. Range is [1, inf) for an integer. Range is (0, inf] for an array-like of floats.\n\n    @defaultValue `4`\n   */\n  alphas?: number | ArrayLike\n\n  /**\n    The number of times the grid is refined. Not used if explicit values of alphas are passed. Range is [1, inf).\n\n    @defaultValue `4`\n   */\n  n_refinements?: number\n\n  /**\n    Determines the cross-validation splitting strategy. Possible inputs for cv are:\n   */\n  cv?: number\n\n  /**\n    The tolerance to declare convergence: if the dual gap goes below this value, iterations are stopped. Range is (0, inf].\n\n    @defaultValue `0.0001`\n   */\n  tol?: number\n\n  /**\n    The tolerance for the elastic net solver used to calculate the descent direction. This parameter controls the accuracy of the search direction for a given column update, not of the overall parameter estimate. Only used for mode=’cd’. Range is (0, inf].\n\n    @defaultValue `0.0001`\n   */\n  enet_tol?: number\n\n  /**\n    Maximum number of iterations.\n\n    @defaultValue `100`\n   */\n  max_iter?: number\n\n  /**\n    The Lasso solver to use: coordinate descent or LARS. Use LARS for very sparse underlying graphs, where number of features is greater than number of samples. Elsewhere prefer cd which is more numerically stable.\n\n    @defaultValue `'cd'`\n   */\n  mode?: 'cd' | 'lars'\n\n  /**\n    Number of jobs to run in parallel. None means 1 unless in a joblib.parallel_backend context. -1 means using all processors. See Glossary for more details.\n   */\n  n_jobs?: number\n\n  /**\n    If verbose is True, the objective function and duality gap are printed at each iteration.\n\n    @defaultValue `false`\n   */\n  verbose?: boolean\n\n  /**\n    If True, data are not centered before computation. Useful when working with data whose mean is almost, but not exactly zero. If False, data are centered before computation.\n\n    @defaultValue `false`\n   */\n  assume_centered?: boolean\n}\n\nexport interface GraphicalLassoCVErrorNormOptions {\n  /**\n    The covariance to compare with.\n   */\n  comp_cov?: ArrayLike[]\n\n  /**\n    The type of norm used to compute the error. Available error types: - ‘frobenius’ (default): sqrt(tr(A^t.A)) - ‘spectral’: sqrt(max(eigenvalues(A^t.A)) where A is the error (comp_cov - self.covariance_).\n\n    @defaultValue `'frobenius'`\n   */\n  norm?: 'frobenius' | 'spectral'\n\n  /**\n    If True (default), the squared error norm is divided by n_features. If False, the squared error norm is not rescaled.\n\n    @defaultValue `true`\n   */\n  scaling?: boolean\n\n  /**\n    Whether to compute the squared error norm or the error norm. If True (default), the squared error norm is returned. If False, the error norm is returned.\n\n    @defaultValue `true`\n   */\n  squared?: boolean\n}\n\nexport interface GraphicalLassoCVFitOptions {\n  /**\n    Data from which to compute the covariance estimate.\n   */\n  X?: ArrayLike[]\n\n  /**\n    Not used, present for API consistency by convention.\n   */\n  y?: any\n}\n\nexport interface GraphicalLassoCVGetPrecisionOptions {\n  /**\n    The precision matrix associated to the current covariance object.\n   */\n  precision_?: ArrayLike[]\n}\n\nexport interface GraphicalLassoCVMahalanobisOptions {\n  /**\n    The observations, the Mahalanobis distances of the which we compute. Observations are assumed to be drawn from the same distribution than the data used in fit.\n   */\n  X?: ArrayLike[]\n}\n\nexport interface GraphicalLassoCVScoreOptions {\n  /**\n    Test data of which we compute the likelihood, where n_samples is the number of samples and n_features is the number of features. X_test is assumed to be drawn from the same distribution than the data used in fit (including centering).\n   */\n  X_test?: ArrayLike[]\n\n  /**\n    Not used, present for API consistency by convention.\n   */\n  y?: any\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  LedoitWolf Estimator.\n\n  Ledoit-Wolf is a particular form of shrinkage, where the shrinkage coefficient is computed using O. Ledoit and M. Wolf’s formula as described in “A Well-Conditioned Estimator for Large-Dimensional Covariance Matrices”, Ledoit and Wolf, Journal of Multivariate Analysis, Volume 88, Issue 2, February 2004, pages 365-411.\n\n  @see https://scikit-learn.org/stable/modules/generated/sklearn.covariance.LedoitWolf.html\n */\nexport class LedoitWolf {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: LedoitWolfOptions) {\n    this.id = `LedoitWolf${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This LedoitWolf instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('LedoitWolf.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.covariance import LedoitWolf\ntry: bridgeLedoitWolf\nexcept NameError: bridgeLedoitWolf = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_LedoitWolf = {'store_precision': ${\n      this.opts['store_precision'] ?? undefined\n    }, 'assume_centered': ${\n      this.opts['assume_centered'] ?? undefined\n    }, 'block_size': ${this.opts['block_size'] ?? undefined}}\n\nctor_LedoitWolf = {k: v for k, v in ctor_LedoitWolf.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeLedoitWolf[${this.id}] = LedoitWolf(**ctor_LedoitWolf)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeLedoitWolf[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Compute the Mean Squared Error between two covariance estimators.\n   */\n  async error_norm(opts: LedoitWolfErrorNormOptions): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LedoitWolf instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LedoitWolf must call init() before error_norm()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LedoitWolf_error_norm = {'comp_cov': np.array(${\n      opts['comp_cov'] ?? undefined\n    }) if ${opts['comp_cov'] !== undefined} else None, 'norm': ${\n      opts['norm'] ?? undefined\n    }, 'scaling': ${opts['scaling'] ?? undefined}, 'squared': ${\n      opts['squared'] ?? undefined\n    }}\n\npms_LedoitWolf_error_norm = {k: v for k, v in pms_LedoitWolf_error_norm.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LedoitWolf_error_norm = bridgeLedoitWolf[${this.id}].error_norm(**pms_LedoitWolf_error_norm)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LedoitWolf_error_norm.tolist() if hasattr(res_LedoitWolf_error_norm, 'tolist') else res_LedoitWolf_error_norm`\n  }\n\n  /**\n    Fit the Ledoit-Wolf shrunk covariance model to X.\n   */\n  async fit(opts: LedoitWolfFitOptions): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LedoitWolf instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LedoitWolf must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LedoitWolf_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_LedoitWolf_fit = {k: v for k, v in pms_LedoitWolf_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LedoitWolf_fit = bridgeLedoitWolf[${this.id}].fit(**pms_LedoitWolf_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LedoitWolf_fit.tolist() if hasattr(res_LedoitWolf_fit, 'tolist') else res_LedoitWolf_fit`\n  }\n\n  /**\n    Getter for the precision matrix.\n   */\n  async get_precision(opts: LedoitWolfGetPrecisionOptions): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LedoitWolf instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LedoitWolf must call init() before get_precision()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LedoitWolf_get_precision = {'precision_': np.array(${\n      opts['precision_'] ?? undefined\n    }) if ${opts['precision_'] !== undefined} else None}\n\npms_LedoitWolf_get_precision = {k: v for k, v in pms_LedoitWolf_get_precision.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LedoitWolf_get_precision = bridgeLedoitWolf[${this.id}].get_precision(**pms_LedoitWolf_get_precision)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LedoitWolf_get_precision.tolist() if hasattr(res_LedoitWolf_get_precision, 'tolist') else res_LedoitWolf_get_precision`\n  }\n\n  /**\n    Compute the squared Mahalanobis distances of given observations.\n   */\n  async mahalanobis(opts: LedoitWolfMahalanobisOptions): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LedoitWolf instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LedoitWolf must call init() before mahalanobis()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LedoitWolf_mahalanobis = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_LedoitWolf_mahalanobis = {k: v for k, v in pms_LedoitWolf_mahalanobis.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LedoitWolf_mahalanobis = bridgeLedoitWolf[${this.id}].mahalanobis(**pms_LedoitWolf_mahalanobis)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LedoitWolf_mahalanobis.tolist() if hasattr(res_LedoitWolf_mahalanobis, 'tolist') else res_LedoitWolf_mahalanobis`\n  }\n\n  /**\n    Compute the log-likelihood of X_test under the estimated Gaussian model.\n\n    The Gaussian model is defined by its mean and covariance matrix which are represented respectively by self.location_ and self.covariance_.\n   */\n  async score(opts: LedoitWolfScoreOptions): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LedoitWolf instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LedoitWolf must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LedoitWolf_score = {'X_test': np.array(${\n      opts['X_test'] ?? undefined\n    }) if ${opts['X_test'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }}\n\npms_LedoitWolf_score = {k: v for k, v in pms_LedoitWolf_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LedoitWolf_score = bridgeLedoitWolf[${this.id}].score(**pms_LedoitWolf_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LedoitWolf_score.tolist() if hasattr(res_LedoitWolf_score, 'tolist') else res_LedoitWolf_score`\n  }\n\n  /**\n    Estimated covariance matrix.\n   */\n  get covariance_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This LedoitWolf instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LedoitWolf must call init() before accessing covariance_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LedoitWolf_covariance_ = bridgeLedoitWolf[${this.id}].covariance_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LedoitWolf_covariance_.tolist() if hasattr(attr_LedoitWolf_covariance_, 'tolist') else attr_LedoitWolf_covariance_`\n    })()\n  }\n\n  /**\n    Estimated location, i.e. the estimated mean.\n   */\n  get location_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LedoitWolf instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LedoitWolf must call init() before accessing location_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LedoitWolf_location_ = bridgeLedoitWolf[${this.id}].location_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LedoitWolf_location_.tolist() if hasattr(attr_LedoitWolf_location_, 'tolist') else attr_LedoitWolf_location_`\n    })()\n  }\n\n  /**\n    Estimated pseudo inverse matrix. (stored only if store_precision is True)\n   */\n  get precision_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This LedoitWolf instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LedoitWolf must call init() before accessing precision_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LedoitWolf_precision_ = bridgeLedoitWolf[${this.id}].precision_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LedoitWolf_precision_.tolist() if hasattr(attr_LedoitWolf_precision_, 'tolist') else attr_LedoitWolf_precision_`\n    })()\n  }\n\n  /**\n    Coefficient in the convex combination used for the computation of the shrunk estimate. Range is [0, 1].\n   */\n  get shrinkage_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LedoitWolf instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LedoitWolf must call init() before accessing shrinkage_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LedoitWolf_shrinkage_ = bridgeLedoitWolf[${this.id}].shrinkage_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LedoitWolf_shrinkage_.tolist() if hasattr(attr_LedoitWolf_shrinkage_, 'tolist') else attr_LedoitWolf_shrinkage_`\n    })()\n  }\n\n  /**\n    Number of features seen during fit.\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LedoitWolf instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LedoitWolf must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LedoitWolf_n_features_in_ = bridgeLedoitWolf[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LedoitWolf_n_features_in_.tolist() if hasattr(attr_LedoitWolf_n_features_in_, 'tolist') else attr_LedoitWolf_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during fit. Defined only when X has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LedoitWolf instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LedoitWolf must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LedoitWolf_feature_names_in_ = bridgeLedoitWolf[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LedoitWolf_feature_names_in_.tolist() if hasattr(attr_LedoitWolf_feature_names_in_, 'tolist') else attr_LedoitWolf_feature_names_in_`\n    })()\n  }\n}\n\nexport interface LedoitWolfOptions {\n  /**\n    Specify if the estimated precision is stored.\n\n    @defaultValue `true`\n   */\n  store_precision?: boolean\n\n  /**\n    If True, data will not be centered before computation. Useful when working with data whose mean is almost, but not exactly zero. If False (default), data will be centered before computation.\n\n    @defaultValue `false`\n   */\n  assume_centered?: boolean\n\n  /**\n    Size of blocks into which the covariance matrix will be split during its Ledoit-Wolf estimation. This is purely a memory optimization and does not affect results.\n\n    @defaultValue `1000`\n   */\n  block_size?: number\n}\n\nexport interface LedoitWolfErrorNormOptions {\n  /**\n    The covariance to compare with.\n   */\n  comp_cov?: ArrayLike[]\n\n  /**\n    The type of norm used to compute the error. Available error types: - ‘frobenius’ (default): sqrt(tr(A^t.A)) - ‘spectral’: sqrt(max(eigenvalues(A^t.A)) where A is the error (comp_cov - self.covariance_).\n\n    @defaultValue `'frobenius'`\n   */\n  norm?: 'frobenius' | 'spectral'\n\n  /**\n    If True (default), the squared error norm is divided by n_features. If False, the squared error norm is not rescaled.\n\n    @defaultValue `true`\n   */\n  scaling?: boolean\n\n  /**\n    Whether to compute the squared error norm or the error norm. If True (default), the squared error norm is returned. If False, the error norm is returned.\n\n    @defaultValue `true`\n   */\n  squared?: boolean\n}\n\nexport interface LedoitWolfFitOptions {\n  /**\n    Training data, where n_samples is the number of samples and n_features is the number of features.\n   */\n  X?: ArrayLike[]\n\n  /**\n    Not used, present for API consistency by convention.\n   */\n  y?: any\n}\n\nexport interface LedoitWolfGetPrecisionOptions {\n  /**\n    The precision matrix associated to the current covariance object.\n   */\n  precision_?: ArrayLike[]\n}\n\nexport interface LedoitWolfMahalanobisOptions {\n  /**\n    The observations, the Mahalanobis distances of the which we compute. Observations are assumed to be drawn from the same distribution than the data used in fit.\n   */\n  X?: ArrayLike[]\n}\n\nexport interface LedoitWolfScoreOptions {\n  /**\n    Test data of which we compute the likelihood, where n_samples is the number of samples and n_features is the number of features. X_test is assumed to be drawn from the same distribution than the data used in fit (including centering).\n   */\n  X_test?: ArrayLike[]\n\n  /**\n    Not used, present for API consistency by convention.\n   */\n  y?: any\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Minimum Covariance Determinant (MCD): robust estimator of covariance.\n\n  The Minimum Covariance Determinant covariance estimator is to be applied on Gaussian-distributed data, but could still be relevant on data drawn from a unimodal, symmetric distribution. It is not meant to be used with multi-modal data (the algorithm used to fit a MinCovDet object is likely to fail in such a case). One should consider projection pursuit methods to deal with multi-modal datasets.\n\n  @see https://scikit-learn.org/stable/modules/generated/sklearn.covariance.MinCovDet.html\n */\nexport class MinCovDet {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: MinCovDetOptions) {\n    this.id = `MinCovDet${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This MinCovDet instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('MinCovDet.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.covariance import MinCovDet\ntry: bridgeMinCovDet\nexcept NameError: bridgeMinCovDet = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_MinCovDet = {'store_precision': ${\n      this.opts['store_precision'] ?? undefined\n    }, 'assume_centered': ${\n      this.opts['assume_centered'] ?? undefined\n    }, 'support_fraction': ${\n      this.opts['support_fraction'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}}\n\nctor_MinCovDet = {k: v for k, v in ctor_MinCovDet.items() if v is not None}`\n\n    await this._py.ex`bridgeMinCovDet[${this.id}] = MinCovDet(**ctor_MinCovDet)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeMinCovDet[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Apply a correction to raw Minimum Covariance Determinant estimates.\n\n    Correction using the empirical correction factor suggested by Rousseeuw and Van Driessen in [RVD].\n   */\n  async correct_covariance(\n    opts: MinCovDetCorrectCovarianceOptions\n  ): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This MinCovDet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MinCovDet must call init() before correct_covariance()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MinCovDet_correct_covariance = {'data': np.array(${\n      opts['data'] ?? undefined\n    }) if ${opts['data'] !== undefined} else None}\n\npms_MinCovDet_correct_covariance = {k: v for k, v in pms_MinCovDet_correct_covariance.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MinCovDet_correct_covariance = bridgeMinCovDet[${this.id}].correct_covariance(**pms_MinCovDet_correct_covariance)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MinCovDet_correct_covariance.tolist() if hasattr(res_MinCovDet_correct_covariance, 'tolist') else res_MinCovDet_correct_covariance`\n  }\n\n  /**\n    Compute the Mean Squared Error between two covariance estimators.\n   */\n  async error_norm(opts: MinCovDetErrorNormOptions): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MinCovDet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MinCovDet must call init() before error_norm()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MinCovDet_error_norm = {'comp_cov': np.array(${\n      opts['comp_cov'] ?? undefined\n    }) if ${opts['comp_cov'] !== undefined} else None, 'norm': ${\n      opts['norm'] ?? undefined\n    }, 'scaling': ${opts['scaling'] ?? undefined}, 'squared': ${\n      opts['squared'] ?? undefined\n    }}\n\npms_MinCovDet_error_norm = {k: v for k, v in pms_MinCovDet_error_norm.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MinCovDet_error_norm = bridgeMinCovDet[${this.id}].error_norm(**pms_MinCovDet_error_norm)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MinCovDet_error_norm.tolist() if hasattr(res_MinCovDet_error_norm, 'tolist') else res_MinCovDet_error_norm`\n  }\n\n  /**\n    Fit a Minimum Covariance Determinant with the FastMCD algorithm.\n   */\n  async fit(opts: MinCovDetFitOptions): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MinCovDet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MinCovDet must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MinCovDet_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_MinCovDet_fit = {k: v for k, v in pms_MinCovDet_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MinCovDet_fit = bridgeMinCovDet[${this.id}].fit(**pms_MinCovDet_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MinCovDet_fit.tolist() if hasattr(res_MinCovDet_fit, 'tolist') else res_MinCovDet_fit`\n  }\n\n  /**\n    Getter for the precision matrix.\n   */\n  async get_precision(opts: MinCovDetGetPrecisionOptions): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MinCovDet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MinCovDet must call init() before get_precision()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MinCovDet_get_precision = {'precision_': np.array(${\n      opts['precision_'] ?? undefined\n    }) if ${opts['precision_'] !== undefined} else None}\n\npms_MinCovDet_get_precision = {k: v for k, v in pms_MinCovDet_get_precision.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MinCovDet_get_precision = bridgeMinCovDet[${this.id}].get_precision(**pms_MinCovDet_get_precision)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MinCovDet_get_precision.tolist() if hasattr(res_MinCovDet_get_precision, 'tolist') else res_MinCovDet_get_precision`\n  }\n\n  /**\n    Compute the squared Mahalanobis distances of given observations.\n   */\n  async mahalanobis(opts: MinCovDetMahalanobisOptions): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MinCovDet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MinCovDet must call init() before mahalanobis()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MinCovDet_mahalanobis = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_MinCovDet_mahalanobis = {k: v for k, v in pms_MinCovDet_mahalanobis.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MinCovDet_mahalanobis = bridgeMinCovDet[${this.id}].mahalanobis(**pms_MinCovDet_mahalanobis)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MinCovDet_mahalanobis.tolist() if hasattr(res_MinCovDet_mahalanobis, 'tolist') else res_MinCovDet_mahalanobis`\n  }\n\n  /**\n    Re-weight raw Minimum Covariance Determinant estimates.\n\n    Re-weight observations using Rousseeuw’s method (equivalent to deleting outlying observations from the data set before computing location and covariance estimates) described in [RVDriessen].\n   */\n  async reweight_covariance(\n    opts: MinCovDetReweightCovarianceOptions\n  ): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MinCovDet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MinCovDet must call init() before reweight_covariance()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MinCovDet_reweight_covariance = {'data': np.array(${\n      opts['data'] ?? undefined\n    }) if ${opts['data'] !== undefined} else None}\n\npms_MinCovDet_reweight_covariance = {k: v for k, v in pms_MinCovDet_reweight_covariance.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MinCovDet_reweight_covariance = bridgeMinCovDet[${this.id}].reweight_covariance(**pms_MinCovDet_reweight_covariance)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MinCovDet_reweight_covariance.tolist() if hasattr(res_MinCovDet_reweight_covariance, 'tolist') else res_MinCovDet_reweight_covariance`\n  }\n\n  /**\n    Compute the log-likelihood of X_test under the estimated Gaussian model.\n\n    The Gaussian model is defined by its mean and covariance matrix which are represented respectively by self.location_ and self.covariance_.\n   */\n  async score(opts: MinCovDetScoreOptions): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MinCovDet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MinCovDet must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MinCovDet_score = {'X_test': np.array(${\n      opts['X_test'] ?? undefined\n    }) if ${opts['X_test'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }}\n\npms_MinCovDet_score = {k: v for k, v in pms_MinCovDet_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MinCovDet_score = bridgeMinCovDet[${this.id}].score(**pms_MinCovDet_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MinCovDet_score.tolist() if hasattr(res_MinCovDet_score, 'tolist') else res_MinCovDet_score`\n  }\n\n  /**\n    The raw robust estimated location before correction and re-weighting.\n   */\n  get raw_location_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MinCovDet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MinCovDet must call init() before accessing raw_location_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MinCovDet_raw_location_ = bridgeMinCovDet[${this.id}].raw_location_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MinCovDet_raw_location_.tolist() if hasattr(attr_MinCovDet_raw_location_, 'tolist') else attr_MinCovDet_raw_location_`\n    })()\n  }\n\n  /**\n    The raw robust estimated covariance before correction and re-weighting.\n   */\n  get raw_covariance_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This MinCovDet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MinCovDet must call init() before accessing raw_covariance_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MinCovDet_raw_covariance_ = bridgeMinCovDet[${this.id}].raw_covariance_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MinCovDet_raw_covariance_.tolist() if hasattr(attr_MinCovDet_raw_covariance_, 'tolist') else attr_MinCovDet_raw_covariance_`\n    })()\n  }\n\n  /**\n    A mask of the observations that have been used to compute the raw robust estimates of location and shape, before correction and re-weighting.\n   */\n  get raw_support_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MinCovDet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MinCovDet must call init() before accessing raw_support_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MinCovDet_raw_support_ = bridgeMinCovDet[${this.id}].raw_support_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MinCovDet_raw_support_.tolist() if hasattr(attr_MinCovDet_raw_support_, 'tolist') else attr_MinCovDet_raw_support_`\n    })()\n  }\n\n  /**\n    Estimated robust location.\n   */\n  get location_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MinCovDet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MinCovDet must call init() before accessing location_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MinCovDet_location_ = bridgeMinCovDet[${this.id}].location_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MinCovDet_location_.tolist() if hasattr(attr_MinCovDet_location_, 'tolist') else attr_MinCovDet_location_`\n    })()\n  }\n\n  /**\n    Estimated robust covariance matrix.\n   */\n  get covariance_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This MinCovDet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MinCovDet must call init() before accessing covariance_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MinCovDet_covariance_ = bridgeMinCovDet[${this.id}].covariance_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MinCovDet_covariance_.tolist() if hasattr(attr_MinCovDet_covariance_, 'tolist') else attr_MinCovDet_covariance_`\n    })()\n  }\n\n  /**\n    Estimated pseudo inverse matrix. (stored only if store_precision is True)\n   */\n  get precision_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This MinCovDet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MinCovDet must call init() before accessing precision_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MinCovDet_precision_ = bridgeMinCovDet[${this.id}].precision_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MinCovDet_precision_.tolist() if hasattr(attr_MinCovDet_precision_, 'tolist') else attr_MinCovDet_precision_`\n    })()\n  }\n\n  /**\n    A mask of the observations that have been used to compute the robust estimates of location and shape.\n   */\n  get support_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MinCovDet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MinCovDet must call init() before accessing support_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MinCovDet_support_ = bridgeMinCovDet[${this.id}].support_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MinCovDet_support_.tolist() if hasattr(attr_MinCovDet_support_, 'tolist') else attr_MinCovDet_support_`\n    })()\n  }\n\n  /**\n    Mahalanobis distances of the training set (on which fit is called) observations.\n   */\n  get dist_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MinCovDet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MinCovDet must call init() before accessing dist_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MinCovDet_dist_ = bridgeMinCovDet[${this.id}].dist_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MinCovDet_dist_.tolist() if hasattr(attr_MinCovDet_dist_, 'tolist') else attr_MinCovDet_dist_`\n    })()\n  }\n\n  /**\n    Number of features seen during fit.\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MinCovDet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MinCovDet must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MinCovDet_n_features_in_ = bridgeMinCovDet[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MinCovDet_n_features_in_.tolist() if hasattr(attr_MinCovDet_n_features_in_, 'tolist') else attr_MinCovDet_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during fit. Defined only when X has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MinCovDet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MinCovDet must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MinCovDet_feature_names_in_ = bridgeMinCovDet[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MinCovDet_feature_names_in_.tolist() if hasattr(attr_MinCovDet_feature_names_in_, 'tolist') else attr_MinCovDet_feature_names_in_`\n    })()\n  }\n}\n\nexport interface MinCovDetOptions {\n  /**\n    Specify if the estimated precision is stored.\n\n    @defaultValue `true`\n   */\n  store_precision?: boolean\n\n  /**\n    If True, the support of the robust location and the covariance estimates is computed, and a covariance estimate is recomputed from it, without centering the data. Useful to work with data whose mean is significantly equal to zero but is not exactly zero. If False, the robust location and covariance are directly computed with the FastMCD algorithm without additional treatment.\n\n    @defaultValue `false`\n   */\n  assume_centered?: boolean\n\n  /**\n    The proportion of points to be included in the support of the raw MCD estimate. Default is None, which implies that the minimum value of support_fraction will be used within the algorithm: (n_sample + n_features + 1) / 2. The parameter must be in the range (0, 1].\n   */\n  support_fraction?: number\n\n  /**\n    Determines the pseudo random number generator for shuffling the data. Pass an int for reproducible results across multiple function calls. See Glossary.\n   */\n  random_state?: number\n}\n\nexport interface MinCovDetCorrectCovarianceOptions {\n  /**\n    The data matrix, with p features and n samples. The data set must be the one which was used to compute the raw estimates.\n   */\n  data?: ArrayLike[]\n}\n\nexport interface MinCovDetErrorNormOptions {\n  /**\n    The covariance to compare with.\n   */\n  comp_cov?: ArrayLike[]\n\n  /**\n    The type of norm used to compute the error. Available error types: - ‘frobenius’ (default): sqrt(tr(A^t.A)) - ‘spectral’: sqrt(max(eigenvalues(A^t.A)) where A is the error (comp_cov - self.covariance_).\n\n    @defaultValue `'frobenius'`\n   */\n  norm?: 'frobenius' | 'spectral'\n\n  /**\n    If True (default), the squared error norm is divided by n_features. If False, the squared error norm is not rescaled.\n\n    @defaultValue `true`\n   */\n  scaling?: boolean\n\n  /**\n    Whether to compute the squared error norm or the error norm. If True (default), the squared error norm is returned. If False, the error norm is returned.\n\n    @defaultValue `true`\n   */\n  squared?: boolean\n}\n\nexport interface MinCovDetFitOptions {\n  /**\n    Training data, where n_samples is the number of samples and n_features is the number of features.\n   */\n  X?: ArrayLike[]\n\n  /**\n    Not used, present for API consistency by convention.\n   */\n  y?: any\n}\n\nexport interface MinCovDetGetPrecisionOptions {\n  /**\n    The precision matrix associated to the current covariance object.\n   */\n  precision_?: ArrayLike[]\n}\n\nexport interface MinCovDetMahalanobisOptions {\n  /**\n    The observations, the Mahalanobis distances of the which we compute. Observations are assumed to be drawn from the same distribution than the data used in fit.\n   */\n  X?: ArrayLike[]\n}\n\nexport interface MinCovDetReweightCovarianceOptions {\n  /**\n    The data matrix, with p features and n samples. The data set must be the one which was used to compute the raw estimates.\n   */\n  data?: ArrayLike[]\n}\n\nexport interface MinCovDetScoreOptions {\n  /**\n    Test data of which we compute the likelihood, where n_samples is the number of samples and n_features is the number of features. X_test is assumed to be drawn from the same distribution than the data used in fit (including centering).\n   */\n  X_test?: ArrayLike[]\n\n  /**\n    Not used, present for API consistency by convention.\n   */\n  y?: any\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Oracle Approximating Shrinkage Estimator as proposed in [1].\n\n  @see https://scikit-learn.org/stable/modules/generated/sklearn.covariance.OAS.html\n */\nexport class OAS {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: OASOptions) {\n    this.id = `OAS${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This OAS instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('OAS.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.covariance import OAS\ntry: bridgeOAS\nexcept NameError: bridgeOAS = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_OAS = {'store_precision': ${\n      this.opts['store_precision'] ?? undefined\n    }, 'assume_centered': ${this.opts['assume_centered'] ?? undefined}}\n\nctor_OAS = {k: v for k, v in ctor_OAS.items() if v is not None}`\n\n    await this._py.ex`bridgeOAS[${this.id}] = OAS(**ctor_OAS)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeOAS[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Compute the Mean Squared Error between two covariance estimators.\n   */\n  async error_norm(opts: OASErrorNormOptions): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This OAS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OAS must call init() before error_norm()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OAS_error_norm = {'comp_cov': np.array(${\n      opts['comp_cov'] ?? undefined\n    }) if ${opts['comp_cov'] !== undefined} else None, 'norm': ${\n      opts['norm'] ?? undefined\n    }, 'scaling': ${opts['scaling'] ?? undefined}, 'squared': ${\n      opts['squared'] ?? undefined\n    }}\n\npms_OAS_error_norm = {k: v for k, v in pms_OAS_error_norm.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OAS_error_norm = bridgeOAS[${this.id}].error_norm(**pms_OAS_error_norm)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OAS_error_norm.tolist() if hasattr(res_OAS_error_norm, 'tolist') else res_OAS_error_norm`\n  }\n\n  /**\n    Fit the Oracle Approximating Shrinkage covariance model to X.\n   */\n  async fit(opts: OASFitOptions): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This OAS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OAS must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OAS_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_OAS_fit = {k: v for k, v in pms_OAS_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py.ex`res_OAS_fit = bridgeOAS[${this.id}].fit(**pms_OAS_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OAS_fit.tolist() if hasattr(res_OAS_fit, 'tolist') else res_OAS_fit`\n  }\n\n  /**\n    Getter for the precision matrix.\n   */\n  async get_precision(opts: OASGetPrecisionOptions): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This OAS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OAS must call init() before get_precision()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OAS_get_precision = {'precision_': np.array(${\n      opts['precision_'] ?? undefined\n    }) if ${opts['precision_'] !== undefined} else None}\n\npms_OAS_get_precision = {k: v for k, v in pms_OAS_get_precision.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OAS_get_precision = bridgeOAS[${this.id}].get_precision(**pms_OAS_get_precision)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OAS_get_precision.tolist() if hasattr(res_OAS_get_precision, 'tolist') else res_OAS_get_precision`\n  }\n\n  /**\n    Compute the squared Mahalanobis distances of given observations.\n   */\n  async mahalanobis(opts: OASMahalanobisOptions): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This OAS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OAS must call init() before mahalanobis()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OAS_mahalanobis = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_OAS_mahalanobis = {k: v for k, v in pms_OAS_mahalanobis.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OAS_mahalanobis = bridgeOAS[${this.id}].mahalanobis(**pms_OAS_mahalanobis)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OAS_mahalanobis.tolist() if hasattr(res_OAS_mahalanobis, 'tolist') else res_OAS_mahalanobis`\n  }\n\n  /**\n    Compute the log-likelihood of X_test under the estimated Gaussian model.\n\n    The Gaussian model is defined by its mean and covariance matrix which are represented respectively by self.location_ and self.covariance_.\n   */\n  async score(opts: OASScoreOptions): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This OAS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OAS must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OAS_score = {'X_test': np.array(${\n      opts['X_test'] ?? undefined\n    }) if ${opts['X_test'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }}\n\npms_OAS_score = {k: v for k, v in pms_OAS_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OAS_score = bridgeOAS[${this.id}].score(**pms_OAS_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OAS_score.tolist() if hasattr(res_OAS_score, 'tolist') else res_OAS_score`\n  }\n\n  /**\n    Estimated covariance matrix.\n   */\n  get covariance_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This OAS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OAS must call init() before accessing covariance_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OAS_covariance_ = bridgeOAS[${this.id}].covariance_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OAS_covariance_.tolist() if hasattr(attr_OAS_covariance_, 'tolist') else attr_OAS_covariance_`\n    })()\n  }\n\n  /**\n    Estimated location, i.e. the estimated mean.\n   */\n  get location_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This OAS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OAS must call init() before accessing location_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_OAS_location_ = bridgeOAS[${this.id}].location_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OAS_location_.tolist() if hasattr(attr_OAS_location_, 'tolist') else attr_OAS_location_`\n    })()\n  }\n\n  /**\n    Estimated pseudo inverse matrix. (stored only if store_precision is True)\n   */\n  get precision_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This OAS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OAS must call init() before accessing precision_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_OAS_precision_ = bridgeOAS[${this.id}].precision_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OAS_precision_.tolist() if hasattr(attr_OAS_precision_, 'tolist') else attr_OAS_precision_`\n    })()\n  }\n\n  /**\n    coefficient in the convex combination used for the computation of the shrunk estimate. Range is [0, 1].\n   */\n  get shrinkage_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This OAS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OAS must call init() before accessing shrinkage_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_OAS_shrinkage_ = bridgeOAS[${this.id}].shrinkage_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OAS_shrinkage_.tolist() if hasattr(attr_OAS_shrinkage_, 'tolist') else attr_OAS_shrinkage_`\n    })()\n  }\n\n  /**\n    Number of features seen during fit.\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This OAS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OAS must call init() before accessing n_features_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OAS_n_features_in_ = bridgeOAS[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OAS_n_features_in_.tolist() if hasattr(attr_OAS_n_features_in_, 'tolist') else attr_OAS_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during fit. Defined only when X has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This OAS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OAS must call init() before accessing feature_names_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OAS_feature_names_in_ = bridgeOAS[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OAS_feature_names_in_.tolist() if hasattr(attr_OAS_feature_names_in_, 'tolist') else attr_OAS_feature_names_in_`\n    })()\n  }\n}\n\nexport interface OASOptions {\n  /**\n    Specify if the estimated precision is stored.\n\n    @defaultValue `true`\n   */\n  store_precision?: boolean\n\n  /**\n    If True, data will not be centered before computation. Useful when working with data whose mean is almost, but not exactly zero. If False (default), data will be centered before computation.\n\n    @defaultValue `false`\n   */\n  assume_centered?: boolean\n}\n\nexport interface OASErrorNormOptions {\n  /**\n    The covariance to compare with.\n   */\n  comp_cov?: ArrayLike[]\n\n  /**\n    The type of norm used to compute the error. Available error types: - ‘frobenius’ (default): sqrt(tr(A^t.A)) - ‘spectral’: sqrt(max(eigenvalues(A^t.A)) where A is the error (comp_cov - self.covariance_).\n\n    @defaultValue `'frobenius'`\n   */\n  norm?: 'frobenius' | 'spectral'\n\n  /**\n    If True (default), the squared error norm is divided by n_features. If False, the squared error norm is not rescaled.\n\n    @defaultValue `true`\n   */\n  scaling?: boolean\n\n  /**\n    Whether to compute the squared error norm or the error norm. If True (default), the squared error norm is returned. If False, the error norm is returned.\n\n    @defaultValue `true`\n   */\n  squared?: boolean\n}\n\nexport interface OASFitOptions {\n  /**\n    Training data, where n_samples is the number of samples and n_features is the number of features.\n   */\n  X?: ArrayLike[]\n\n  /**\n    Not used, present for API consistency by convention.\n   */\n  y?: any\n}\n\nexport interface OASGetPrecisionOptions {\n  /**\n    The precision matrix associated to the current covariance object.\n   */\n  precision_?: ArrayLike[]\n}\n\nexport interface OASMahalanobisOptions {\n  /**\n    The observations, the Mahalanobis distances of the which we compute. Observations are assumed to be drawn from the same distribution than the data used in fit.\n   */\n  X?: ArrayLike[]\n}\n\nexport interface OASScoreOptions {\n  /**\n    Test data of which we compute the likelihood, where n_samples is the number of samples and n_features is the number of features. X_test is assumed to be drawn from the same distribution than the data used in fit (including centering).\n   */\n  X_test?: ArrayLike[]\n\n  /**\n    Not used, present for API consistency by convention.\n   */\n  y?: any\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Covariance estimator with shrinkage.\n\n  @see https://scikit-learn.org/stable/modules/generated/sklearn.covariance.ShrunkCovariance.html\n */\nexport class ShrunkCovariance {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: ShrunkCovarianceOptions) {\n    this.id = `ShrunkCovariance${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This ShrunkCovariance instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('ShrunkCovariance.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.covariance import ShrunkCovariance\ntry: bridgeShrunkCovariance\nexcept NameError: bridgeShrunkCovariance = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_ShrunkCovariance = {'store_precision': ${\n      this.opts['store_precision'] ?? undefined\n    }, 'assume_centered': ${\n      this.opts['assume_centered'] ?? undefined\n    }, 'shrinkage': ${this.opts['shrinkage'] ?? undefined}}\n\nctor_ShrunkCovariance = {k: v for k, v in ctor_ShrunkCovariance.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeShrunkCovariance[${this.id}] = ShrunkCovariance(**ctor_ShrunkCovariance)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeShrunkCovariance[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Compute the Mean Squared Error between two covariance estimators.\n   */\n  async error_norm(opts: ShrunkCovarianceErrorNormOptions): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This ShrunkCovariance instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ShrunkCovariance must call init() before error_norm()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_ShrunkCovariance_error_norm = {'comp_cov': np.array(${\n      opts['comp_cov'] ?? undefined\n    }) if ${opts['comp_cov'] !== undefined} else None, 'norm': ${\n      opts['norm'] ?? undefined\n    }, 'scaling': ${opts['scaling'] ?? undefined}, 'squared': ${\n      opts['squared'] ?? undefined\n    }}\n\npms_ShrunkCovariance_error_norm = {k: v for k, v in pms_ShrunkCovariance_error_norm.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ShrunkCovariance_error_norm = bridgeShrunkCovariance[${this.id}].error_norm(**pms_ShrunkCovariance_error_norm)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ShrunkCovariance_error_norm.tolist() if hasattr(res_ShrunkCovariance_error_norm, 'tolist') else res_ShrunkCovariance_error_norm`\n  }\n\n  /**\n    Fit the shrunk covariance model to X.\n   */\n  async fit(opts: ShrunkCovarianceFitOptions): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This ShrunkCovariance instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ShrunkCovariance must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_ShrunkCovariance_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_ShrunkCovariance_fit = {k: v for k, v in pms_ShrunkCovariance_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ShrunkCovariance_fit = bridgeShrunkCovariance[${this.id}].fit(**pms_ShrunkCovariance_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ShrunkCovariance_fit.tolist() if hasattr(res_ShrunkCovariance_fit, 'tolist') else res_ShrunkCovariance_fit`\n  }\n\n  /**\n    Getter for the precision matrix.\n   */\n  async get_precision(opts: ShrunkCovarianceGetPrecisionOptions): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This ShrunkCovariance instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ShrunkCovariance must call init() before get_precision()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_ShrunkCovariance_get_precision = {'precision_': np.array(${\n      opts['precision_'] ?? undefined\n    }) if ${opts['precision_'] !== undefined} else None}\n\npms_ShrunkCovariance_get_precision = {k: v for k, v in pms_ShrunkCovariance_get_precision.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ShrunkCovariance_get_precision = bridgeShrunkCovariance[${this.id}].get_precision(**pms_ShrunkCovariance_get_precision)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ShrunkCovariance_get_precision.tolist() if hasattr(res_ShrunkCovariance_get_precision, 'tolist') else res_ShrunkCovariance_get_precision`\n  }\n\n  /**\n    Compute the squared Mahalanobis distances of given observations.\n   */\n  async mahalanobis(\n    opts: ShrunkCovarianceMahalanobisOptions\n  ): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This ShrunkCovariance instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ShrunkCovariance must call init() before mahalanobis()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_ShrunkCovariance_mahalanobis = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_ShrunkCovariance_mahalanobis = {k: v for k, v in pms_ShrunkCovariance_mahalanobis.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ShrunkCovariance_mahalanobis = bridgeShrunkCovariance[${this.id}].mahalanobis(**pms_ShrunkCovariance_mahalanobis)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ShrunkCovariance_mahalanobis.tolist() if hasattr(res_ShrunkCovariance_mahalanobis, 'tolist') else res_ShrunkCovariance_mahalanobis`\n  }\n\n  /**\n    Compute the log-likelihood of X_test under the estimated Gaussian model.\n\n    The Gaussian model is defined by its mean and covariance matrix which are represented respectively by self.location_ and self.covariance_.\n   */\n  async score(opts: ShrunkCovarianceScoreOptions): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This ShrunkCovariance instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ShrunkCovariance must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_ShrunkCovariance_score = {'X_test': np.array(${\n      opts['X_test'] ?? undefined\n    }) if ${opts['X_test'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }}\n\npms_ShrunkCovariance_score = {k: v for k, v in pms_ShrunkCovariance_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ShrunkCovariance_score = bridgeShrunkCovariance[${this.id}].score(**pms_ShrunkCovariance_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ShrunkCovariance_score.tolist() if hasattr(res_ShrunkCovariance_score, 'tolist') else res_ShrunkCovariance_score`\n  }\n\n  /**\n    Estimated covariance matrix\n   */\n  get covariance_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This ShrunkCovariance instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ShrunkCovariance must call init() before accessing covariance_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ShrunkCovariance_covariance_ = bridgeShrunkCovariance[${this.id}].covariance_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ShrunkCovariance_covariance_.tolist() if hasattr(attr_ShrunkCovariance_covariance_, 'tolist') else attr_ShrunkCovariance_covariance_`\n    })()\n  }\n\n  /**\n    Estimated location, i.e. the estimated mean.\n   */\n  get location_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This ShrunkCovariance instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ShrunkCovariance must call init() before accessing location_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ShrunkCovariance_location_ = bridgeShrunkCovariance[${this.id}].location_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ShrunkCovariance_location_.tolist() if hasattr(attr_ShrunkCovariance_location_, 'tolist') else attr_ShrunkCovariance_location_`\n    })()\n  }\n\n  /**\n    Estimated pseudo inverse matrix. (stored only if store_precision is True)\n   */\n  get precision_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This ShrunkCovariance instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ShrunkCovariance must call init() before accessing precision_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ShrunkCovariance_precision_ = bridgeShrunkCovariance[${this.id}].precision_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ShrunkCovariance_precision_.tolist() if hasattr(attr_ShrunkCovariance_precision_, 'tolist') else attr_ShrunkCovariance_precision_`\n    })()\n  }\n\n  /**\n    Number of features seen during fit.\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This ShrunkCovariance instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ShrunkCovariance must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ShrunkCovariance_n_features_in_ = bridgeShrunkCovariance[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ShrunkCovariance_n_features_in_.tolist() if hasattr(attr_ShrunkCovariance_n_features_in_, 'tolist') else attr_ShrunkCovariance_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during fit. Defined only when X has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This ShrunkCovariance instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ShrunkCovariance must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ShrunkCovariance_feature_names_in_ = bridgeShrunkCovariance[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ShrunkCovariance_feature_names_in_.tolist() if hasattr(attr_ShrunkCovariance_feature_names_in_, 'tolist') else attr_ShrunkCovariance_feature_names_in_`\n    })()\n  }\n}\n\nexport interface ShrunkCovarianceOptions {\n  /**\n    Specify if the estimated precision is stored.\n\n    @defaultValue `true`\n   */\n  store_precision?: boolean\n\n  /**\n    If True, data will not be centered before computation. Useful when working with data whose mean is almost, but not exactly zero. If False, data will be centered before computation.\n\n    @defaultValue `false`\n   */\n  assume_centered?: boolean\n\n  /**\n    Coefficient in the convex combination used for the computation of the shrunk estimate. Range is [0, 1].\n\n    @defaultValue `0.1`\n   */\n  shrinkage?: number\n}\n\nexport interface ShrunkCovarianceErrorNormOptions {\n  /**\n    The covariance to compare with.\n   */\n  comp_cov?: ArrayLike[]\n\n  /**\n    The type of norm used to compute the error. Available error types: - ‘frobenius’ (default): sqrt(tr(A^t.A)) - ‘spectral’: sqrt(max(eigenvalues(A^t.A)) where A is the error (comp_cov - self.covariance_).\n\n    @defaultValue `'frobenius'`\n   */\n  norm?: 'frobenius' | 'spectral'\n\n  /**\n    If True (default), the squared error norm is divided by n_features. If False, the squared error norm is not rescaled.\n\n    @defaultValue `true`\n   */\n  scaling?: boolean\n\n  /**\n    Whether to compute the squared error norm or the error norm. If True (default), the squared error norm is returned. If False, the error norm is returned.\n\n    @defaultValue `true`\n   */\n  squared?: boolean\n}\n\nexport interface ShrunkCovarianceFitOptions {\n  /**\n    Training data, where n_samples is the number of samples and n_features is the number of features.\n   */\n  X?: ArrayLike[]\n\n  /**\n    Not used, present for API consistency by convention.\n   */\n  y?: any\n}\n\nexport interface ShrunkCovarianceGetPrecisionOptions {\n  /**\n    The precision matrix associated to the current covariance object.\n   */\n  precision_?: ArrayLike[]\n}\n\nexport interface ShrunkCovarianceMahalanobisOptions {\n  /**\n    The observations, the Mahalanobis distances of the which we compute. Observations are assumed to be drawn from the same distribution than the data used in fit.\n   */\n  X?: ArrayLike[]\n}\n\nexport interface ShrunkCovarianceScoreOptions {\n  /**\n    Test data of which we compute the likelihood, where n_samples is the number of samples and n_features is the number of features. X_test is assumed to be drawn from the same distribution than the data used in fit (including centering).\n   */\n  X_test?: ArrayLike[]\n\n  /**\n    Not used, present for API consistency by convention.\n   */\n  y?: any\n}\n"],"mappings":"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","names":["crypto","crypto","crypto","crypto","crypto","crypto","crypto"]}