import { PythonBridge, NDArray, ArrayLike } from '@/sklearn/types';
/**
  Constructs a transformer from an arbitrary callable.

  A FunctionTransformer forwards its X (and optionally y) arguments to a user-defined function or function object and returns the result of this function. This is useful for stateless transformations such as taking the log of frequencies, doing custom scaling, etc.

  Note: If a lambda is used as the function, then the resulting transformer will not be pickleable.

  @see https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.FunctionTransformer.html
 */
export declare class FunctionTransformer {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: FunctionTransformerOptions);
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Fit transformer by checking X.
  
      If validate is True, X will be checked.
     */
    fit(opts: FunctionTransformerFitOptions): Promise<any>;
    /**
      Fit to data, then transform it.
  
      Fits transformer to X and y with optional parameters fit_params and returns a transformed version of X.
     */
    fit_transform(opts: FunctionTransformerFitTransformOptions): Promise<any[]>;
    /**
      Get output feature names for transformation.
  
      This method is only defined if feature_names_out is not None.
     */
    get_feature_names_out(opts: FunctionTransformerGetFeatureNamesOutOptions): Promise<any>;
    /**
      Transform X using the inverse function.
     */
    inverse_transform(opts: FunctionTransformerInverseTransformOptions): Promise<ArrayLike>;
    /**
      Set output container.
  
      See Introducing the set_output API for an example on how to use the API.
     */
    set_output(opts: FunctionTransformerSetOutputOptions): Promise<any>;
    /**
      Transform X using the forward function.
     */
    transform(opts: FunctionTransformerTransformOptions): Promise<ArrayLike>;
    /**
      Number of features seen during fit.
     */
    get n_features_in_(): Promise<number>;
    /**
      Names of features seen during fit. Defined only when X has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
}
export interface FunctionTransformerOptions {
    /**
      The callable to use for the transformation. This will be passed the same arguments as transform, with args and kwargs forwarded. If func is None, then func will be the identity function.
     */
    func?: any;
    /**
      The callable to use for the inverse transformation. This will be passed the same arguments as inverse transform, with args and kwargs forwarded. If inverse_func is None, then inverse_func will be the identity function.
     */
    inverse_func?: any;
    /**
      Indicate that the input X array should be checked before calling func. The possibilities are:
  
      @defaultValue `false`
     */
    validate?: boolean;
    /**
      Indicate that func accepts a sparse matrix as input. If validate is False, this has no effect. Otherwise, if accept_sparse is false, sparse matrix inputs will cause an exception to be raised.
  
      @defaultValue `false`
     */
    accept_sparse?: boolean;
    /**
      Whether to check that or func followed by inverse_func leads to the original inputs. It can be used for a sanity check, raising a warning when the condition is not fulfilled.
  
      @defaultValue `true`
     */
    check_inverse?: boolean;
    /**
      Determines the list of feature names that will be returned by the get_feature_names_out method. If it is ‘one-to-one’, then the output feature names will be equal to the input feature names. If it is a callable, then it must take two positional arguments: this FunctionTransformer (self) and an array-like of input feature names (input_features). It must return an array-like of output feature names. The get_feature_names_out method is only defined if feature_names_out is not None.
  
      See get_feature_names_out for more details.
     */
    feature_names_out?: 'one-to-one';
    /**
      Dictionary of additional keyword arguments to pass to func.
     */
    kw_args?: any;
    /**
      Dictionary of additional keyword arguments to pass to inverse_func.
     */
    inv_kw_args?: any;
}
export interface FunctionTransformerFitOptions {
    /**
      Input array.
     */
    X?: any;
    /**
      Not used, present here for API consistency by convention.
     */
    y?: any;
}
export interface FunctionTransformerFitTransformOptions {
    /**
      Input samples.
     */
    X?: ArrayLike[];
    /**
      Target values (None for unsupervised transformations).
     */
    y?: ArrayLike;
    /**
      Additional fit parameters.
     */
    fit_params?: any;
}
export interface FunctionTransformerGetFeatureNamesOutOptions {
    /**
      Input feature names.
     */
    input_features?: any;
}
export interface FunctionTransformerInverseTransformOptions {
    /**
      Input array.
     */
    X?: any;
}
export interface FunctionTransformerSetOutputOptions {
    /**
      Configure output of transform and fit_transform.
     */
    transform?: 'default' | 'pandas';
}
export interface FunctionTransformerTransformOptions {
    /**
      Input array.
     */
    X?: any;
}
//# sourceMappingURL=FunctionTransformer.d.ts.map