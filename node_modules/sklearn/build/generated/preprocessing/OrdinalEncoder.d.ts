import { PythonBridge, NDArray, ArrayLike } from '@/sklearn/types';
/**
  Encode categorical features as an integer array.

  The input to this transformer should be an array-like of integers or strings, denoting the values taken on by categorical (discrete) features. The features are converted to ordinal integers. This results in a single column of integers (0 to n_categories - 1) per feature.

  @see https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OrdinalEncoder.html
 */
export declare class OrdinalEncoder {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: OrdinalEncoderOptions);
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Fit the OrdinalEncoder to X.
     */
    fit(opts: OrdinalEncoderFitOptions): Promise<any>;
    /**
      Fit to data, then transform it.
  
      Fits transformer to X and y with optional parameters fit_params and returns a transformed version of X.
     */
    fit_transform(opts: OrdinalEncoderFitTransformOptions): Promise<any[]>;
    /**
      Get output feature names for transformation.
     */
    get_feature_names_out(opts: OrdinalEncoderGetFeatureNamesOutOptions): Promise<any>;
    /**
      Convert the data back to the original representation.
     */
    inverse_transform(opts: OrdinalEncoderInverseTransformOptions): Promise<NDArray[]>;
    /**
      Set output container.
  
      See Introducing the set_output API for an example on how to use the API.
     */
    set_output(opts: OrdinalEncoderSetOutputOptions): Promise<any>;
    /**
      Transform X to ordinal codes.
     */
    transform(opts: OrdinalEncoderTransformOptions): Promise<NDArray[]>;
    /**
      The categories of each feature determined during fit (in order of the features in X and corresponding with the output of transform). This does not include categories that weren’t seen during fit.
     */
    get categories_(): Promise<any>;
    /**
      Number of features seen during fit.
     */
    get n_features_in_(): Promise<number>;
    /**
      Names of features seen during fit. Defined only when X has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
}
export interface OrdinalEncoderOptions {
    /**
      Categories (unique values) per feature:
  
      @defaultValue `'auto'`
     */
    categories?: 'auto';
    /**
      Desired dtype of output.
     */
    dtype?: any;
    /**
      When set to ‘error’ an error will be raised in case an unknown categorical feature is present during transform. When set to ‘use_encoded_value’, the encoded value of unknown categories will be set to the value given for the parameter unknown_value. In inverse_transform, an unknown category will be denoted as None.
  
      @defaultValue `'error'`
     */
    handle_unknown?: 'error' | 'use_encoded_value';
    /**
      When the parameter handle_unknown is set to ‘use_encoded_value’, this parameter is required and will set the encoded value of unknown categories. It has to be distinct from the values used to encode any of the categories in fit. If set to np.nan, the dtype parameter must be a float dtype.
     */
    unknown_value?: number;
    /**
      Encoded value of missing categories. If set to np.nan, then the dtype parameter must be a float dtype.
     */
    encoded_missing_value?: number;
}
export interface OrdinalEncoderFitOptions {
    /**
      The data to determine the categories of each feature.
     */
    X?: ArrayLike[];
    /**
      Ignored. This parameter exists only for compatibility with Pipeline.
     */
    y?: any;
}
export interface OrdinalEncoderFitTransformOptions {
    /**
      Input samples.
     */
    X?: ArrayLike[];
    /**
      Target values (None for unsupervised transformations).
     */
    y?: ArrayLike;
    /**
      Additional fit parameters.
     */
    fit_params?: any;
}
export interface OrdinalEncoderGetFeatureNamesOutOptions {
    /**
      Input features.
     */
    input_features?: any;
}
export interface OrdinalEncoderInverseTransformOptions {
    /**
      The transformed data.
     */
    X?: ArrayLike[];
}
export interface OrdinalEncoderSetOutputOptions {
    /**
      Configure output of transform and fit_transform.
     */
    transform?: 'default' | 'pandas';
}
export interface OrdinalEncoderTransformOptions {
    /**
      The data to encode.
     */
    X?: ArrayLike[];
}
//# sourceMappingURL=OrdinalEncoder.d.ts.map