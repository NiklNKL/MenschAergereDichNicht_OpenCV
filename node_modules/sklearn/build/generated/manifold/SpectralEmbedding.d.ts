import { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types';
/**
  Spectral embedding for non-linear dimensionality reduction.

  Forms an affinity matrix given by the specified function and applies spectral decomposition to the corresponding graph laplacian. The resulting transformation is given by the value of the eigenvectors for each data point.

  Note : Laplacian Eigenmaps is the actual algorithm implemented here.

  @see https://scikit-learn.org/stable/modules/generated/sklearn.manifold.SpectralEmbedding.html
 */
export declare class SpectralEmbedding {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: SpectralEmbeddingOptions);
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Fit the model from data in X.
     */
    fit(opts: SpectralEmbeddingFitOptions): Promise<any>;
    /**
      Fit the model from data in X and transform X.
     */
    fit_transform(opts: SpectralEmbeddingFitTransformOptions): Promise<ArrayLike[]>;
    /**
      Spectral embedding of the training matrix.
     */
    get embedding_(): Promise<NDArray[]>;
    /**
      Affinity_matrix constructed from samples or precomputed.
     */
    get affinity_matrix_(): Promise<NDArray[]>;
    /**
      Number of features seen during fit.
     */
    get n_features_in_(): Promise<number>;
    /**
      Names of features seen during fit. Defined only when X has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
    /**
      Number of nearest neighbors effectively used.
     */
    get n_neighbors_(): Promise<number>;
}
export interface SpectralEmbeddingOptions {
    /**
      The dimension of the projected subspace.
  
      @defaultValue `2`
     */
    n_components?: number;
    /**
      ‘nearest_neighbors’ : construct the affinity matrix by computing a graph of nearest neighbors.
  
      @defaultValue `'nearest_neighbors'`
     */
    affinity?: 'nearest_neighbors' | 'rbf' | 'precomputed' | 'precomputed_nearest_neighbors';
    /**
      Kernel coefficient for rbf kernel. If None, gamma will be set to 1/n_features.
     */
    gamma?: number;
    /**
      A pseudo random number generator used for the initialization of the lobpcg eigen vectors decomposition when eigen_solver == 'amg', and for the K-Means initialization. Use an int to make the results deterministic across calls (See Glossary).
     */
    random_state?: number;
    /**
      The eigenvalue decomposition strategy to use. AMG requires pyamg to be installed. It can be faster on very large, sparse problems. If None, then 'arpack' is used.
     */
    eigen_solver?: 'arpack' | 'lobpcg' | 'amg';
    /**
      Stopping criterion for eigendecomposition of the Laplacian matrix. If eigen_tol="auto" then the passed tolerance will depend on the eigen_solver:
  
      @defaultValue `'auto'`
     */
    eigen_tol?: number;
    /**
      Number of nearest neighbors for nearest_neighbors graph building. If None, n_neighbors will be set to max(n_samples/10, 1).
     */
    n_neighbors?: number;
    /**
      The number of parallel jobs to run. None means 1 unless in a joblib.parallel_backend context. -1 means using all processors. See Glossary for more details.
     */
    n_jobs?: number;
}
export interface SpectralEmbeddingFitOptions {
    /**
      Training vector, where n_samples is the number of samples and n_features is the number of features.
  
      If affinity is “precomputed” X : {array-like, sparse matrix}, shape (n_samples, n_samples), Interpret X as precomputed adjacency graph computed from samples.
     */
    X?: ArrayLike | SparseMatrix[];
    /**
      Not used, present for API consistency by convention.
     */
    y?: any;
}
export interface SpectralEmbeddingFitTransformOptions {
    /**
      Training vector, where n_samples is the number of samples and n_features is the number of features.
  
      If affinity is “precomputed” X : {array-like, sparse matrix} of shape (n_samples, n_samples), Interpret X as precomputed adjacency graph computed from samples.
     */
    X?: ArrayLike | SparseMatrix[];
    /**
      Not used, present for API consistency by convention.
     */
    y?: any;
}
//# sourceMappingURL=SpectralEmbedding.d.ts.map