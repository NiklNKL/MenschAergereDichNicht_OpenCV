import { PythonBridge, NDArray, ArrayLike } from '@/sklearn/types';
/**
  Pipeline of transforms with a final estimator.

  Sequentially apply a list of transforms and a final estimator. Intermediate steps of the pipeline must be ‘transforms’, that is, they must implement fit and transform methods. The final estimator only needs to implement fit. The transformers in the pipeline can be cached using memory argument.

  The purpose of the pipeline is to assemble several steps that can be cross-validated together while setting different parameters. For this, it enables setting parameters of the various steps using their names and the parameter name separated by a '__', as in the example below. A step’s estimator may be replaced entirely by setting the parameter with its name to another estimator, or a transformer removed by setting it to 'passthrough' or None.

  @see https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html
 */
export declare class Pipeline {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: PipelineOptions);
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Transform the data, and apply decision_function with the final estimator.
  
      Call transform of each transformer in the pipeline. The transformed data are finally passed to the final estimator that calls decision_function method. Only valid if the final estimator implements decision_function.
     */
    decision_function(opts: PipelineDecisionFunctionOptions): Promise<NDArray[]>;
    /**
      Fit the model.
  
      Fit all the transformers one after the other and transform the data. Finally, fit the transformed data using the final estimator.
     */
    fit(opts: PipelineFitOptions): Promise<any>;
    /**
      Transform the data, and apply fit_predict with the final estimator.
  
      Call fit_transform of each transformer in the pipeline. The transformed data are finally passed to the final estimator that calls fit_predict method. Only valid if the final estimator implements fit_predict.
     */
    fit_predict(opts: PipelineFitPredictOptions): Promise<NDArray>;
    /**
      Fit the model and transform with the final estimator.
  
      Fits all the transformers one after the other and transform the data. Then uses fit_transform on transformed data with the final estimator.
     */
    fit_transform(opts: PipelineFitTransformOptions): Promise<NDArray[]>;
    /**
      Get output feature names for transformation.
  
      Transform input features using the pipeline.
     */
    get_feature_names_out(opts: PipelineGetFeatureNamesOutOptions): Promise<any>;
    /**
      Apply inverse_transform for each step in a reverse order.
  
      All estimators in the pipeline must support inverse_transform.
     */
    inverse_transform(opts: PipelineInverseTransformOptions): Promise<NDArray[]>;
    /**
      Transform the data, and apply predict with the final estimator.
  
      Call transform of each transformer in the pipeline. The transformed data are finally passed to the final estimator that calls predict method. Only valid if the final estimator implements predict.
     */
    predict(opts: PipelinePredictOptions): Promise<NDArray>;
    /**
      Transform the data, and apply predict_log_proba with the final estimator.
  
      Call transform of each transformer in the pipeline. The transformed data are finally passed to the final estimator that calls predict_log_proba method. Only valid if the final estimator implements predict_log_proba.
     */
    predict_log_proba(opts: PipelinePredictLogProbaOptions): Promise<NDArray[]>;
    /**
      Transform the data, and apply predict_proba with the final estimator.
  
      Call transform of each transformer in the pipeline. The transformed data are finally passed to the final estimator that calls predict_proba method. Only valid if the final estimator implements predict_proba.
     */
    predict_proba(opts: PipelinePredictProbaOptions): Promise<NDArray[]>;
    /**
      Transform the data, and apply score with the final estimator.
  
      Call transform of each transformer in the pipeline. The transformed data are finally passed to the final estimator that calls score method. Only valid if the final estimator implements score.
     */
    score(opts: PipelineScoreOptions): Promise<number>;
    /**
      Transform the data, and apply score_samples with the final estimator.
  
      Call transform of each transformer in the pipeline. The transformed data are finally passed to the final estimator that calls score_samples method. Only valid if the final estimator implements score_samples.
     */
    score_samples(opts: PipelineScoreSamplesOptions): Promise<NDArray>;
    /**
      Set the output container when "transform" and "fit_transform" are called.
  
      Calling set_output will set the output of all estimators in steps.
     */
    set_output(opts: PipelineSetOutputOptions): Promise<any>;
    /**
      Transform the data, and apply transform with the final estimator.
  
      Call transform of each transformer in the pipeline. The transformed data are finally passed to the final estimator that calls transform method. Only valid if the final estimator implements transform.
  
      This also works where final estimator is None in which case all prior transformations are applied.
     */
    transform(opts: PipelineTransformOptions): Promise<NDArray[]>;
}
export interface PipelineOptions {
    /**
      List of (name, transform) tuples (implementing fit/transform) that are chained in sequential order. The last transform must be an estimator.
     */
    steps?: any;
    /**
      Used to cache the fitted transformers of the pipeline. By default, no caching is performed. If a string is given, it is the path to the caching directory. Enabling caching triggers a clone of the transformers before fitting. Therefore, the transformer instance given to the pipeline cannot be inspected directly. Use the attribute named_steps or steps to inspect estimators within the pipeline. Caching the transformers is advantageous when fitting is time consuming.
     */
    memory?: string;
    /**
      If True, the time elapsed while fitting each step will be printed as it is completed.
  
      @defaultValue `false`
     */
    verbose?: boolean;
}
export interface PipelineDecisionFunctionOptions {
    /**
      Data to predict on. Must fulfill input requirements of first step of the pipeline.
     */
    X?: any;
}
export interface PipelineFitOptions {
    /**
      Training data. Must fulfill input requirements of first step of the pipeline.
     */
    X?: any;
    /**
      Training targets. Must fulfill label requirements for all steps of the pipeline.
     */
    y?: any;
    /**
      Parameters passed to the fit method of each step, where each parameter name is prefixed such that parameter p for step s has key s__p.
     */
    fit_params?: any;
}
export interface PipelineFitPredictOptions {
    /**
      Training data. Must fulfill input requirements of first step of the pipeline.
     */
    X?: any;
    /**
      Training targets. Must fulfill label requirements for all steps of the pipeline.
     */
    y?: any;
    /**
      Parameters passed to the fit method of each step, where each parameter name is prefixed such that parameter p for step s has key s__p.
     */
    fit_params?: any;
}
export interface PipelineFitTransformOptions {
    /**
      Training data. Must fulfill input requirements of first step of the pipeline.
     */
    X?: any;
    /**
      Training targets. Must fulfill label requirements for all steps of the pipeline.
     */
    y?: any;
    /**
      Parameters passed to the fit method of each step, where each parameter name is prefixed such that parameter p for step s has key s__p.
     */
    fit_params?: any;
}
export interface PipelineGetFeatureNamesOutOptions {
    /**
      Input features.
     */
    input_features?: any;
}
export interface PipelineInverseTransformOptions {
    /**
      Data samples, where n_samples is the number of samples and n_features is the number of features. Must fulfill input requirements of last step of pipeline’s inverse_transform method.
     */
    Xt?: ArrayLike[];
}
export interface PipelinePredictOptions {
    /**
      Data to predict on. Must fulfill input requirements of first step of the pipeline.
     */
    X?: any;
    /**
      Parameters to the predict called at the end of all transformations in the pipeline. Note that while this may be used to return uncertainties from some models with return_std or return_cov, uncertainties that are generated by the transformations in the pipeline are not propagated to the final estimator.
     */
    predict_params?: any;
}
export interface PipelinePredictLogProbaOptions {
    /**
      Data to predict on. Must fulfill input requirements of first step of the pipeline.
     */
    X?: any;
    /**
      Parameters to the predict_log_proba called at the end of all transformations in the pipeline.
     */
    predict_log_proba_params?: any;
}
export interface PipelinePredictProbaOptions {
    /**
      Data to predict on. Must fulfill input requirements of first step of the pipeline.
     */
    X?: any;
    /**
      Parameters to the predict_proba called at the end of all transformations in the pipeline.
     */
    predict_proba_params?: any;
}
export interface PipelineScoreOptions {
    /**
      Data to predict on. Must fulfill input requirements of first step of the pipeline.
     */
    X?: any;
    /**
      Targets used for scoring. Must fulfill label requirements for all steps of the pipeline.
     */
    y?: any;
    /**
      If not None, this argument is passed as sample_weight keyword argument to the score method of the final estimator.
     */
    sample_weight?: ArrayLike;
}
export interface PipelineScoreSamplesOptions {
    /**
      Data to predict on. Must fulfill input requirements of first step of the pipeline.
     */
    X?: any;
}
export interface PipelineSetOutputOptions {
    /**
      Configure output of transform and fit_transform.
     */
    transform?: 'default' | 'pandas';
}
export interface PipelineTransformOptions {
    /**
      Data to transform. Must fulfill input requirements of first step of the pipeline.
     */
    X?: any;
}
//# sourceMappingURL=Pipeline.d.ts.map