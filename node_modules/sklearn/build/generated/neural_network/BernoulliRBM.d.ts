import { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types';
/**
  Bernoulli Restricted Boltzmann Machine (RBM).

  A Restricted Boltzmann Machine with binary visible units and binary hidden units. Parameters are estimated using Stochastic Maximum Likelihood (SML), also known as Persistent Contrastive Divergence (PCD) [2].

  The time complexity of this implementation is O(d ** 2) assuming d ~ n_features ~ n_components.

  @see https://scikit-learn.org/stable/modules/generated/sklearn.neural_network.BernoulliRBM.html
 */
export declare class BernoulliRBM {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: BernoulliRBMOptions);
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Fit the model to the data X.
     */
    fit(opts: BernoulliRBMFitOptions): Promise<any>;
    /**
      Fit to data, then transform it.
  
      Fits transformer to X and y with optional parameters fit_params and returns a transformed version of X.
     */
    fit_transform(opts: BernoulliRBMFitTransformOptions): Promise<any[]>;
    /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: ["class_name0", "class_name1", "class_name2"].
     */
    get_feature_names_out(opts: BernoulliRBMGetFeatureNamesOutOptions): Promise<any>;
    /**
      Perform one Gibbs sampling step.
     */
    gibbs(opts: BernoulliRBMGibbsOptions): Promise<NDArray[]>;
    /**
      Fit the model to the partial segment of the data X.
     */
    partial_fit(opts: BernoulliRBMPartialFitOptions): Promise<any>;
    /**
      Compute the pseudo-likelihood of X.
     */
    score_samples(opts: BernoulliRBMScoreSamplesOptions): Promise<NDArray>;
    /**
      Set output container.
  
      See Introducing the set_output API for an example on how to use the API.
     */
    set_output(opts: BernoulliRBMSetOutputOptions): Promise<any>;
    /**
      Compute the hidden layer activation probabilities, P(h=1|v=X).
     */
    transform(opts: BernoulliRBMTransformOptions): Promise<NDArray[]>;
    /**
      Biases of the hidden units.
     */
    get intercept_hidden_(): Promise<ArrayLike>;
    /**
      Biases of the visible units.
     */
    get intercept_visible_(): Promise<ArrayLike>;
    /**
      Weight matrix, where n_features is the number of visible units and n_components is the number of hidden units.
     */
    get components_(): Promise<ArrayLike[]>;
    /**
      Hidden Activation sampled from the model distribution, where batch_size is the number of examples per minibatch and n_components is the number of hidden units.
     */
    get h_samples_(): Promise<ArrayLike[]>;
    /**
      Number of features seen during fit.
     */
    get n_features_in_(): Promise<number>;
    /**
      Names of features seen during fit. Defined only when X has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
}
export interface BernoulliRBMOptions {
    /**
      Number of binary hidden units.
  
      @defaultValue `256`
     */
    n_components?: number;
    /**
      The learning rate for weight updates. It is highly recommended to tune this hyper-parameter. Reasonable values are in the 10**[0., -3.] range.
  
      @defaultValue `0.1`
     */
    learning_rate?: number;
    /**
      Number of examples per minibatch.
  
      @defaultValue `10`
     */
    batch_size?: number;
    /**
      Number of iterations/sweeps over the training dataset to perform during training.
  
      @defaultValue `10`
     */
    n_iter?: number;
    /**
      The verbosity level. The default, zero, means silent mode. Range of values is [0, inf].
  
      @defaultValue `0`
     */
    verbose?: number;
    /**
      Determines random number generation for:
     */
    random_state?: number;
}
export interface BernoulliRBMFitOptions {
    /**
      Training data.
     */
    X?: ArrayLike | SparseMatrix[];
    /**
      Target values (None for unsupervised transformations).
     */
    y?: ArrayLike;
}
export interface BernoulliRBMFitTransformOptions {
    /**
      Input samples.
     */
    X?: ArrayLike[];
    /**
      Target values (None for unsupervised transformations).
     */
    y?: ArrayLike;
    /**
      Additional fit parameters.
     */
    fit_params?: any;
}
export interface BernoulliRBMGetFeatureNamesOutOptions {
    /**
      Only used to validate feature names with the names seen in fit.
     */
    input_features?: any;
}
export interface BernoulliRBMGibbsOptions {
    /**
      Values of the visible layer to start from.
     */
    v?: NDArray[];
}
export interface BernoulliRBMPartialFitOptions {
    /**
      Training data.
     */
    X?: NDArray[];
    /**
      Target values (None for unsupervised transformations).
     */
    y?: ArrayLike;
}
export interface BernoulliRBMScoreSamplesOptions {
    /**
      Values of the visible layer. Must be all-boolean (not checked).
     */
    X?: ArrayLike | SparseMatrix[];
}
export interface BernoulliRBMSetOutputOptions {
    /**
      Configure output of transform and fit_transform.
     */
    transform?: 'default' | 'pandas';
}
export interface BernoulliRBMTransformOptions {
    /**
      The data to be transformed.
     */
    X?: ArrayLike | SparseMatrix[];
}
//# sourceMappingURL=BernoulliRBM.d.ts.map