import { PythonBridge, ArrayLike, SparseMatrix } from '@/sklearn/types';
/**
  Transforms lists of feature-value mappings to vectors.

  This transformer turns lists of mappings (dict-like objects) of feature names to feature values into Numpy arrays or scipy.sparse matrices for use with scikit-learn estimators.

  When feature values are strings, this transformer will do a binary one-hot (aka one-of-K) coding: one boolean-valued feature is constructed for each of the possible string values that the feature can take on. For instance, a feature “f” that can take on the values “ham” and “spam” will become two features in the output, one signifying “f=ham”, the other “f=spam”.

  If a feature value is a sequence or set of strings, this transformer will iterate over the values and will count the occurrences of each string value.

  However, note that this transformer will only do a binary one-hot encoding when feature values are of type string. If categorical features are represented as numeric values such as int or iterables of strings, the DictVectorizer can be followed by OneHotEncoder to complete binary one-hot encoding.

  Features that do not occur in a sample (mapping) will have a zero value in the resulting array/matrix.

  @see https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.DictVectorizer.html
 */
export declare class DictVectorizer {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: DictVectorizerOptions);
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Learn a list of feature name -> indices mappings.
     */
    fit(opts: DictVectorizerFitOptions): Promise<any>;
    /**
      Learn a list of feature name -> indices mappings and transform X.
  
      Like fit(X) followed by transform(X), but does not require materializing X in memory.
     */
    fit_transform(opts: DictVectorizerFitTransformOptions): Promise<SparseMatrix>;
    /**
      Get output feature names for transformation.
     */
    get_feature_names_out(opts: DictVectorizerGetFeatureNamesOutOptions): Promise<any>;
    /**
      Transform array or sparse matrix X back to feature mappings.
  
      X must have been produced by this DictVectorizer’s transform or fit_transform method; it may only have passed through transformers that preserve the number of features and their order.
  
      In the case of one-hot/one-of-K coding, the constructed feature names and values are returned rather than the original ones.
     */
    inverse_transform(opts: DictVectorizerInverseTransformOptions): Promise<any[]>;
    /**
      Restrict the features to those in support using feature selection.
  
      This function modifies the estimator in-place.
     */
    restrict(opts: DictVectorizerRestrictOptions): Promise<any>;
    /**
      Set output container.
  
      See Introducing the set_output API for an example on how to use the API.
     */
    set_output(opts: DictVectorizerSetOutputOptions): Promise<any>;
    /**
      Transform feature->value dicts to array or sparse matrix.
  
      Named features not encountered during fit or fit_transform will be silently ignored.
     */
    transform(opts: DictVectorizerTransformOptions): Promise<SparseMatrix>;
    /**
      A dictionary mapping feature names to feature indices.
     */
    get vocabulary_(): Promise<any>;
    /**
      A list of length n_features containing the feature names (e.g., “f=ham” and “f=spam”).
     */
    get feature_names_(): Promise<any[]>;
}
export interface DictVectorizerOptions {
    /**
      The type of feature values. Passed to Numpy array/scipy.sparse matrix constructors as the dtype argument.
     */
    dtype?: any;
    /**
      Separator string used when constructing new features for one-hot coding.
  
      @defaultValue `'='`
     */
    separator?: string;
    /**
      Whether transform should produce scipy.sparse matrices.
  
      @defaultValue `true`
     */
    sparse?: boolean;
    /**
      Whether feature_names_ and vocabulary_ should be sorted when fitting.
  
      @defaultValue `true`
     */
    sort?: boolean;
}
export interface DictVectorizerFitOptions {
    /**
      Dict(s) or Mapping(s) from feature names (arbitrary Python objects) to feature values (strings or convertible to dtype).
     */
    X?: any;
    /**
      Ignored parameter.
     */
    y?: any;
}
export interface DictVectorizerFitTransformOptions {
    /**
      Dict(s) or Mapping(s) from feature names (arbitrary Python objects) to feature values (strings or convertible to dtype).
     */
    X?: any;
    /**
      Ignored parameter.
     */
    y?: any;
}
export interface DictVectorizerGetFeatureNamesOutOptions {
    /**
      Not used, present here for API consistency by convention.
     */
    input_features?: any;
}
export interface DictVectorizerInverseTransformOptions {
    /**
      Sample matrix.
     */
    X?: ArrayLike | SparseMatrix[];
    /**
      Constructor for feature mappings. Must conform to the collections.Mapping API.
     */
    dict_type?: any;
}
export interface DictVectorizerRestrictOptions {
    /**
      Boolean mask or list of indices (as returned by the get_support member of feature selectors).
     */
    support?: ArrayLike;
    /**
      Whether support is a list of indices.
  
      @defaultValue `false`
     */
    indices?: boolean;
}
export interface DictVectorizerSetOutputOptions {
    /**
      Configure output of transform and fit_transform.
     */
    transform?: 'default' | 'pandas';
}
export interface DictVectorizerTransformOptions {
    /**
      Dict(s) or Mapping(s) from feature names (arbitrary Python objects) to feature values (strings or convertible to dtype).
     */
    X?: any[];
}
//# sourceMappingURL=DictVectorizer.d.ts.map