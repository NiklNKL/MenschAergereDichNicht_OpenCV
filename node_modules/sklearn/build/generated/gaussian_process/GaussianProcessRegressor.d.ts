import { PythonBridge, NDArray, ArrayLike } from '@/sklearn/types';
/**
  Gaussian process regression (GPR).

  The implementation is based on Algorithm 2.1 of [RW2006].

  In addition to standard scikit-learn estimator API, GaussianProcessRegressor:

  @see https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.GaussianProcessRegressor.html
 */
export declare class GaussianProcessRegressor {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: GaussianProcessRegressorOptions);
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Fit Gaussian process regression model.
     */
    fit(opts: GaussianProcessRegressorFitOptions): Promise<any>;
    /**
      Return log-marginal likelihood of theta for training data.
     */
    log_marginal_likelihood(opts: GaussianProcessRegressorLogMarginalLikelihoodOptions): Promise<number>;
    /**
      Predict using the Gaussian process regression model.
  
      We can also predict based on an unfitted model by using the GP prior. In addition to the mean of the predictive distribution, optionally also returns its standard deviation (return_std=True) or covariance (return_cov=True). Note that at most one of the two can be requested.
     */
    predict(opts: GaussianProcessRegressorPredictOptions): Promise<NDArray>;
    /**
      Draw samples from Gaussian process and evaluate at X.
     */
    sample_y(opts: GaussianProcessRegressorSampleYOptions): Promise<any>;
    /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \(R^2\) is defined as \((1 - \frac{u}{v})\), where \(u\) is the residual sum of squares ((y_true - y_pred)** 2).sum() and \(v\) is the total sum of squares ((y_true - y_true.mean()) ** 2).sum(). The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of y, disregarding the input features, would get a \(R^2\) score of 0.0.
     */
    score(opts: GaussianProcessRegressorScoreOptions): Promise<number>;
    /**
      Feature vectors or other representations of training data (also required for prediction).
     */
    get X_train_(): Promise<ArrayLike[]>;
    /**
      Target values in training data (also required for prediction).
     */
    get y_train_(): Promise<ArrayLike>;
    /**
      The kernel used for prediction. The structure of the kernel is the same as the one passed as parameter but with optimized hyperparameters.
     */
    get kernel_(): Promise<any>;
    /**
      Lower-triangular Cholesky decomposition of the kernel in X_train_.
     */
    get L_(): Promise<ArrayLike[]>;
    /**
      Dual coefficients of training data points in kernel space.
     */
    get alpha_(): Promise<ArrayLike>;
    /**
      The log-marginal-likelihood of self.kernel_.theta.
     */
    get log_marginal_likelihood_value_(): Promise<number>;
    /**
      Number of features seen during fit.
     */
    get n_features_in_(): Promise<number>;
    /**
      Names of features seen during fit. Defined only when X has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
}
export interface GaussianProcessRegressorOptions {
    /**
      The kernel specifying the covariance function of the GP. If None is passed, the kernel ConstantKernel(1.0, constant_value_bounds="fixed") * RBF(1.0, length_scale_bounds="fixed") is used as default. Note that the kernel hyperparameters are optimized during fitting unless the bounds are marked as “fixed”.
     */
    kernel?: any;
    /**
      Value added to the diagonal of the kernel matrix during fitting. This can prevent a potential numerical issue during fitting, by ensuring that the calculated values form a positive definite matrix. It can also be interpreted as the variance of additional Gaussian measurement noise on the training observations. Note that this is different from using a WhiteKernel. If an array is passed, it must have the same number of entries as the data used for fitting and is used as datapoint-dependent noise level. Allowing to specify the noise level directly as a parameter is mainly for convenience and for consistency with Ridge.
  
      @defaultValue `1e-10`
     */
    alpha?: number | NDArray;
    /**
      Can either be one of the internally supported optimizers for optimizing the kernel’s parameters, specified by a string, or an externally defined optimizer passed as a callable. If a callable is passed, it must have the signature:
  
      @defaultValue `'fmin_l_bfgs_b'`
     */
    optimizer?: 'fmin_l_bfgs_b';
    /**
      The number of restarts of the optimizer for finding the kernel’s parameters which maximize the log-marginal likelihood. The first run of the optimizer is performed from the kernel’s initial parameters, the remaining ones (if any) from thetas sampled log-uniform randomly from the space of allowed theta-values. If greater than 0, all bounds must be finite. Note that n_restarts_optimizer == 0 implies that one run is performed.
  
      @defaultValue `0`
     */
    n_restarts_optimizer?: number;
    /**
      Whether or not to normalize the target values y by removing the mean and scaling to unit-variance. This is recommended for cases where zero-mean, unit-variance priors are used. Note that, in this implementation, the normalisation is reversed before the GP predictions are reported.
  
      @defaultValue `false`
     */
    normalize_y?: boolean;
    /**
      If True, a persistent copy of the training data is stored in the object. Otherwise, just a reference to the training data is stored, which might cause predictions to change if the data is modified externally.
  
      @defaultValue `true`
     */
    copy_X_train?: boolean;
    /**
      Determines random number generation used to initialize the centers. Pass an int for reproducible results across multiple function calls. See Glossary.
     */
    random_state?: number;
}
export interface GaussianProcessRegressorFitOptions {
    /**
      Feature vectors or other representations of training data.
     */
    X?: ArrayLike[];
    /**
      Target values.
     */
    y?: ArrayLike;
}
export interface GaussianProcessRegressorLogMarginalLikelihoodOptions {
    /**
      Kernel hyperparameters for which the log-marginal likelihood is evaluated. If None, the precomputed log_marginal_likelihood of self.kernel_.theta is returned.
     */
    theta?: any;
    /**
      If True, the gradient of the log-marginal likelihood with respect to the kernel hyperparameters at position theta is returned additionally. If True, theta must not be None.
  
      @defaultValue `false`
     */
    eval_gradient?: boolean;
    /**
      If True, the kernel attribute is copied. If False, the kernel attribute is modified, but may result in a performance improvement.
  
      @defaultValue `true`
     */
    clone_kernel?: boolean;
}
export interface GaussianProcessRegressorPredictOptions {
    /**
      Query points where the GP is evaluated.
     */
    X?: ArrayLike[];
    /**
      If True, the standard-deviation of the predictive distribution at the query points is returned along with the mean.
  
      @defaultValue `false`
     */
    return_std?: boolean;
    /**
      If True, the covariance of the joint predictive distribution at the query points is returned along with the mean.
  
      @defaultValue `false`
     */
    return_cov?: boolean;
}
export interface GaussianProcessRegressorSampleYOptions {
    /**
      Query points where the GP is evaluated.
     */
    X?: ArrayLike[];
    /**
      Number of samples drawn from the Gaussian process per query point.
  
      @defaultValue `1`
     */
    n_samples?: number;
    /**
      Determines random number generation to randomly draw samples. Pass an int for reproducible results across multiple function calls. See Glossary.
  
      @defaultValue `0`
     */
    random_state?: number;
}
export interface GaussianProcessRegressorScoreOptions {
    /**
      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape (n_samples, n_samples_fitted), where n_samples_fitted is the number of samples used in the fitting for the estimator.
     */
    X?: ArrayLike[];
    /**
      True values for X.
     */
    y?: ArrayLike;
    /**
      Sample weights.
     */
    sample_weight?: ArrayLike;
}
//# sourceMappingURL=GaussianProcessRegressor.d.ts.map