import { PythonBridge, NDArray, ArrayLike } from '@/sklearn/types';
/**
  Variational Bayesian estimation of a Gaussian mixture.

  This class allows to infer an approximate posterior distribution over the parameters of a Gaussian mixture distribution. The effective number of components can be inferred from the data.

  This class implements two types of prior for the weights distribution: a finite mixture model with Dirichlet distribution and an infinite mixture model with the Dirichlet Process. In practice Dirichlet Process inference algorithm is approximated and uses a truncated distribution with a fixed maximum number of components (called the Stick-breaking representation). The number of components actually used almost always depends on the data.

  @see https://scikit-learn.org/stable/modules/generated/sklearn.mixture.BayesianGaussianMixture.html
 */
export declare class BayesianGaussianMixture {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: BayesianGaussianMixtureOptions);
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Estimate model parameters with the EM algorithm.
  
      The method fits the model n_init times and sets the parameters with which the model has the largest likelihood or lower bound. Within each trial, the method iterates between E-step and M-step for max_iter times until the change of likelihood or lower bound is less than tol, otherwise, a ConvergenceWarning is raised. If warm_start is True, then n_init is ignored and a single initialization is performed upon the first call. Upon consecutive calls, training starts where it left off.
     */
    fit(opts: BayesianGaussianMixtureFitOptions): Promise<any>;
    /**
      Estimate model parameters using X and predict the labels for X.
  
      The method fits the model n_init times and sets the parameters with which the model has the largest likelihood or lower bound. Within each trial, the method iterates between E-step and M-step for max_iter times until the change of likelihood or lower bound is less than tol, otherwise, a ConvergenceWarning is raised. After fitting, it predicts the most probable label for the input data points.
     */
    fit_predict(opts: BayesianGaussianMixtureFitPredictOptions): Promise<any>;
    /**
      Predict the labels for the data samples in X using trained model.
     */
    predict(opts: BayesianGaussianMixturePredictOptions): Promise<any>;
    /**
      Evaluate the components’ density for each sample.
     */
    predict_proba(opts: BayesianGaussianMixturePredictProbaOptions): Promise<any>;
    /**
      Generate random samples from the fitted Gaussian distribution.
     */
    sample(opts: BayesianGaussianMixtureSampleOptions): Promise<any>;
    /**
      Compute the per-sample average log-likelihood of the given data X.
     */
    score(opts: BayesianGaussianMixtureScoreOptions): Promise<number>;
    /**
      Compute the log-likelihood of each sample.
     */
    score_samples(opts: BayesianGaussianMixtureScoreSamplesOptions): Promise<any>;
    /**
      The weights of each mixture components.
     */
    get weights_(): Promise<ArrayLike>;
    /**
      The mean of each mixture component.
     */
    get means_(): Promise<ArrayLike[]>;
    /**
      The covariance of each mixture component. The shape depends on covariance_type:
     */
    get covariances_(): Promise<ArrayLike>;
    /**
      The precision matrices for each component in the mixture. A precision matrix is the inverse of a covariance matrix. A covariance matrix is symmetric positive definite so the mixture of Gaussian can be equivalently parameterized by the precision matrices. Storing the precision matrices instead of the covariance matrices makes it more efficient to compute the log-likelihood of new samples at test time. The shape depends on covariance_type:
     */
    get precisions_(): Promise<ArrayLike>;
    /**
      The cholesky decomposition of the precision matrices of each mixture component. A precision matrix is the inverse of a covariance matrix. A covariance matrix is symmetric positive definite so the mixture of Gaussian can be equivalently parameterized by the precision matrices. Storing the precision matrices instead of the covariance matrices makes it more efficient to compute the log-likelihood of new samples at test time. The shape depends on covariance_type:
     */
    get precisions_cholesky_(): Promise<ArrayLike>;
    /**
      True when convergence was reached in fit(), False otherwise.
     */
    get converged_(): Promise<boolean>;
    /**
      Number of step used by the best fit of inference to reach the convergence.
     */
    get n_iter_(): Promise<number>;
    /**
      Lower bound value on the model evidence (of the training data) of the best fit of inference.
     */
    get lower_bound_(): Promise<number>;
    /**
      The dirichlet concentration of each component on the weight distribution (Dirichlet). The type depends on weight_concentration_prior_type:
     */
    get weight_concentration_prior_(): Promise<number>;
    /**
      The dirichlet concentration of each component on the weight distribution (Dirichlet).
     */
    get weight_concentration_(): Promise<ArrayLike>;
    /**
      The precision prior on the mean distribution (Gaussian). Controls the extent of where means can be placed. Larger values concentrate the cluster means around mean_prior. If mean_precision_prior is set to None, mean_precision_prior_ is set to 1.
     */
    get mean_precision_prior_(): Promise<number>;
    /**
      The precision of each components on the mean distribution (Gaussian).
     */
    get mean_precision_(): Promise<ArrayLike>;
    /**
      The prior on the mean distribution (Gaussian).
     */
    get mean_prior_(): Promise<ArrayLike>;
    /**
      The prior of the number of degrees of freedom on the covariance distributions (Wishart).
     */
    get degrees_of_freedom_prior_(): Promise<number>;
    /**
      The number of degrees of freedom of each components in the model.
     */
    get degrees_of_freedom_(): Promise<ArrayLike>;
    /**
      The prior on the covariance distribution (Wishart). The shape depends on covariance_type:
     */
    get covariance_prior_(): Promise<number | ArrayLike>;
    /**
      Number of features seen during fit.
     */
    get n_features_in_(): Promise<number>;
    /**
      Names of features seen during fit. Defined only when X has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
}
export interface BayesianGaussianMixtureOptions {
    /**
      The number of mixture components. Depending on the data and the value of the weight_concentration_prior the model can decide to not use all the components by setting some component weights_ to values very close to zero. The number of effective components is therefore smaller than n_components.
  
      @defaultValue `1`
     */
    n_components?: number;
    /**
      String describing the type of covariance parameters to use. Must be one of:
  
      @defaultValue `'full'`
     */
    covariance_type?: 'full' | 'tied' | 'diag' | 'spherical';
    /**
      The convergence threshold. EM iterations will stop when the lower bound average gain on the likelihood (of the training data with respect to the model) is below this threshold.
  
      @defaultValue `0.001`
     */
    tol?: number;
    /**
      Non-negative regularization added to the diagonal of covariance. Allows to assure that the covariance matrices are all positive.
  
      @defaultValue `0.000001`
     */
    reg_covar?: number;
    /**
      The number of EM iterations to perform.
  
      @defaultValue `100`
     */
    max_iter?: number;
    /**
      The number of initializations to perform. The result with the highest lower bound value on the likelihood is kept.
  
      @defaultValue `1`
     */
    n_init?: number;
    /**
      The method used to initialize the weights, the means and the covariances. String must be one of:
  
      @defaultValue `'kmeans'`
     */
    init_params?: 'kmeans' | 'k-means++' | 'random' | 'random_from_data';
    /**
      String describing the type of the weight concentration prior.
  
      @defaultValue `'dirichlet_process'`
     */
    weight_concentration_prior_type?: 'dirichlet_process' | 'dirichlet_distribution';
    /**
      The dirichlet concentration of each component on the weight distribution (Dirichlet). This is commonly called gamma in the literature. The higher concentration puts more mass in the center and will lead to more components being active, while a lower concentration parameter will lead to more mass at the edge of the mixture weights simplex. The value of the parameter must be greater than 0. If it is None, it’s set to 1. / n_components.
     */
    weight_concentration_prior?: number;
    /**
      The precision prior on the mean distribution (Gaussian). Controls the extent of where means can be placed. Larger values concentrate the cluster means around mean_prior. The value of the parameter must be greater than 0. If it is None, it is set to 1.
     */
    mean_precision_prior?: number;
    /**
      The prior on the mean distribution (Gaussian). If it is None, it is set to the mean of X.
     */
    mean_prior?: ArrayLike;
    /**
      The prior of the number of degrees of freedom on the covariance distributions (Wishart). If it is None, it’s set to n_features.
     */
    degrees_of_freedom_prior?: number;
    /**
      The prior on the covariance distribution (Wishart). If it is None, the emiprical covariance prior is initialized using the covariance of X. The shape depends on covariance_type:
     */
    covariance_prior?: number | ArrayLike;
    /**
      Controls the random seed given to the method chosen to initialize the parameters (see init_params). In addition, it controls the generation of random samples from the fitted distribution (see the method sample). Pass an int for reproducible output across multiple function calls. See Glossary.
     */
    random_state?: number;
    /**
      If ‘warm_start’ is True, the solution of the last fitting is used as initialization for the next call of fit(). This can speed up convergence when fit is called several times on similar problems. See the Glossary.
  
      @defaultValue `false`
     */
    warm_start?: boolean;
    /**
      Enable verbose output. If 1 then it prints the current initialization and each iteration step. If greater than 1 then it prints also the log probability and the time needed for each step.
  
      @defaultValue `0`
     */
    verbose?: number;
    /**
      Number of iteration done before the next print.
  
      @defaultValue `10`
     */
    verbose_interval?: number;
}
export interface BayesianGaussianMixtureFitOptions {
    /**
      List of n_features-dimensional data points. Each row corresponds to a single data point.
     */
    X?: ArrayLike[];
    /**
      Not used, present for API consistency by convention.
     */
    y?: any;
}
export interface BayesianGaussianMixtureFitPredictOptions {
    /**
      List of n_features-dimensional data points. Each row corresponds to a single data point.
     */
    X?: ArrayLike[];
    /**
      Not used, present for API consistency by convention.
     */
    y?: any;
}
export interface BayesianGaussianMixturePredictOptions {
    /**
      List of n_features-dimensional data points. Each row corresponds to a single data point.
     */
    X?: ArrayLike[];
}
export interface BayesianGaussianMixturePredictProbaOptions {
    /**
      List of n_features-dimensional data points. Each row corresponds to a single data point.
     */
    X?: ArrayLike[];
}
export interface BayesianGaussianMixtureSampleOptions {
    /**
      Number of samples to generate.
  
      @defaultValue `1`
     */
    n_samples?: number;
}
export interface BayesianGaussianMixtureScoreOptions {
    /**
      List of n_features-dimensional data points. Each row corresponds to a single data point.
     */
    X?: ArrayLike[];
    /**
      Not used, present for API consistency by convention.
     */
    y?: any;
}
export interface BayesianGaussianMixtureScoreSamplesOptions {
    /**
      List of n_features-dimensional data points. Each row corresponds to a single data point.
     */
    X?: ArrayLike[];
}
//# sourceMappingURL=BayesianGaussianMixture.d.ts.map