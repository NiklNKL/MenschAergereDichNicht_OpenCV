import { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types';
/**
  Kernel Principal component analysis (KPCA) [1].

  Non-linear dimensionality reduction through the use of kernels (see Pairwise metrics, Affinities and Kernels).

  It uses the scipy.linalg.eigh LAPACK implementation of the full SVD or the scipy.sparse.linalg.eigsh ARPACK implementation of the truncated SVD, depending on the shape of the input data and the number of components to extract. It can also use a randomized truncated SVD by the method proposed in [3], see eigen_solver.

  @see https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.KernelPCA.html
 */
export declare class KernelPCA {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: KernelPCAOptions);
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Fit the model from data in X.
     */
    fit(opts: KernelPCAFitOptions): Promise<any>;
    /**
      Fit the model from data in X and transform X.
     */
    fit_transform(opts: KernelPCAFitTransformOptions): Promise<NDArray[]>;
    /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: ["class_name0", "class_name1", "class_name2"].
     */
    get_feature_names_out(opts: KernelPCAGetFeatureNamesOutOptions): Promise<any>;
    /**
      Transform X back to original space.
  
      inverse_transform approximates the inverse transformation using a learned pre-image. The pre-image is learned by kernel ridge regression of the original data on their low-dimensional representation vectors.
     */
    inverse_transform(opts: KernelPCAInverseTransformOptions): Promise<NDArray[]>;
    /**
      Set output container.
  
      See Introducing the set_output API for an example on how to use the API.
     */
    set_output(opts: KernelPCASetOutputOptions): Promise<any>;
    /**
      Transform X.
     */
    transform(opts: KernelPCATransformOptions): Promise<NDArray[]>;
    /**
      Eigenvalues of the centered kernel matrix in decreasing order. If n_components and remove_zero_eig are not set, then all values are stored.
     */
    get eigenvalues_(): Promise<NDArray>;
    /**
      Eigenvectors of the centered kernel matrix. If n_components and remove_zero_eig are not set, then all components are stored.
     */
    get eigenvectors_(): Promise<NDArray[]>;
    /**
      Inverse transform matrix. Only available when fit_inverse_transform is True.
     */
    get dual_coef_(): Promise<NDArray[]>;
    /**
      Projection of the fitted data on the kernel principal components. Only available when fit_inverse_transform is True.
     */
    get X_transformed_fit_(): Promise<NDArray[]>;
    /**
      The data used to fit the model. If copy_X=False, then X_fit_ is a reference. This attribute is used for the calls to transform.
     */
    get X_fit_(): Promise<NDArray[]>;
    /**
      Number of features seen during fit.
     */
    get n_features_in_(): Promise<number>;
    /**
      Names of features seen during fit. Defined only when X has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
}
export interface KernelPCAOptions {
    /**
      Number of components. If None, all non-zero components are kept.
     */
    n_components?: number;
    /**
      Kernel used for PCA.
  
      @defaultValue `'linear'`
     */
    kernel?: 'linear' | 'poly' | 'rbf' | 'sigmoid' | 'cosine' | 'precomputed';
    /**
      Kernel coefficient for rbf, poly and sigmoid kernels. Ignored by other kernels. If gamma is None, then it is set to 1/n_features.
     */
    gamma?: number;
    /**
      Degree for poly kernels. Ignored by other kernels.
  
      @defaultValue `3`
     */
    degree?: number;
    /**
      Independent term in poly and sigmoid kernels. Ignored by other kernels.
  
      @defaultValue `1`
     */
    coef0?: number;
    /**
      Parameters (keyword arguments) and values for kernel passed as callable object. Ignored by other kernels.
     */
    kernel_params?: any;
    /**
      Hyperparameter of the ridge regression that learns the inverse transform (when fit_inverse_transform=True).
  
      @defaultValue `1`
     */
    alpha?: number;
    /**
      Learn the inverse transform for non-precomputed kernels (i.e. learn to find the pre-image of a point). This method is based on [2].
  
      @defaultValue `false`
     */
    fit_inverse_transform?: boolean;
    /**
      Select eigensolver to use. If n_components is much less than the number of training samples, randomized (or arpack to a smaller extent) may be more efficient than the dense eigensolver. Randomized SVD is performed according to the method of Halko et al [3].
  
      @defaultValue `'auto'`
     */
    eigen_solver?: 'auto' | 'dense' | 'arpack' | 'randomized';
    /**
      Convergence tolerance for arpack. If 0, optimal value will be chosen by arpack.
  
      @defaultValue `0`
     */
    tol?: number;
    /**
      Maximum number of iterations for arpack. If None, optimal value will be chosen by arpack.
     */
    max_iter?: number;
    /**
      Number of iterations for the power method computed by svd_solver == ‘randomized’. When ‘auto’, it is set to 7 when n_components < 0.1 * min(X.shape), other it is set to 4.
  
      @defaultValue `'auto'`
     */
    iterated_power?: 'auto';
    /**
      If True, then all components with zero eigenvalues are removed, so that the number of components in the output may be < n_components (and sometimes even zero due to numerical instability). When n_components is None, this parameter is ignored and components with zero eigenvalues are removed regardless.
  
      @defaultValue `false`
     */
    remove_zero_eig?: boolean;
    /**
      Used when eigen_solver == ‘arpack’ or ‘randomized’. Pass an int for reproducible results across multiple function calls. See Glossary.
     */
    random_state?: number;
    /**
      If True, input X is copied and stored by the model in the X_fit_ attribute. If no further changes will be done to X, setting copy_X=False saves memory by storing a reference.
  
      @defaultValue `true`
     */
    copy_X?: boolean;
    /**
      The number of parallel jobs to run. None means 1 unless in a joblib.parallel_backend context. -1 means using all processors. See Glossary for more details.
     */
    n_jobs?: number;
}
export interface KernelPCAFitOptions {
    /**
      Training vector, where n_samples is the number of samples and n_features is the number of features.
     */
    X?: ArrayLike | SparseMatrix[];
    /**
      Not used, present for API consistency by convention.
     */
    y?: any;
}
export interface KernelPCAFitTransformOptions {
    /**
      Training vector, where n_samples is the number of samples and n_features is the number of features.
     */
    X?: ArrayLike | SparseMatrix[];
    /**
      Not used, present for API consistency by convention.
     */
    y?: any;
    /**
      Parameters (keyword arguments) and values passed to the fit_transform instance.
     */
    params?: any;
}
export interface KernelPCAGetFeatureNamesOutOptions {
    /**
      Only used to validate feature names with the names seen in fit.
     */
    input_features?: any;
}
export interface KernelPCAInverseTransformOptions {
    /**
      Training vector, where n_samples is the number of samples and n_features is the number of features.
     */
    X?: ArrayLike | SparseMatrix[];
}
export interface KernelPCASetOutputOptions {
    /**
      Configure output of transform and fit_transform.
     */
    transform?: 'default' | 'pandas';
}
export interface KernelPCATransformOptions {
    /**
      Training vector, where n_samples is the number of samples and n_features is the number of features.
     */
    X?: ArrayLike | SparseMatrix[];
}
//# sourceMappingURL=KernelPCA.d.ts.map