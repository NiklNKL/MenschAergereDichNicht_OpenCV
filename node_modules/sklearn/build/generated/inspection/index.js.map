{"version":3,"sources":["../../../src/generated/inspection/DecisionBoundaryDisplay.ts","../../../src/generated/inspection/PartialDependenceDisplay.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Decisions boundary visualization.\n\n  It is recommended to use from_estimator to create a DecisionBoundaryDisplay. All parameters are stored as attributes.\n\n  @see https://scikit-learn.org/stable/modules/generated/sklearn.inspection.DecisionBoundaryDisplay.html\n */\nexport class DecisionBoundaryDisplay {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: DecisionBoundaryDisplayOptions) {\n    this.id = `DecisionBoundaryDisplay${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This DecisionBoundaryDisplay instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'DecisionBoundaryDisplay.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.inspection import DecisionBoundaryDisplay\ntry: bridgeDecisionBoundaryDisplay\nexcept NameError: bridgeDecisionBoundaryDisplay = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_DecisionBoundaryDisplay = {'xx0': np.array(${\n      this.opts['xx0'] ?? undefined\n    }) if ${this.opts['xx0'] !== undefined} else None, 'xx1': np.array(${\n      this.opts['xx1'] ?? undefined\n    }) if ${this.opts['xx1'] !== undefined} else None, 'response': np.array(${\n      this.opts['response'] ?? undefined\n    }) if ${this.opts['response'] !== undefined} else None, 'xlabel': ${\n      this.opts['xlabel'] ?? undefined\n    }, 'ylabel': ${this.opts['ylabel'] ?? undefined}}\n\nctor_DecisionBoundaryDisplay = {k: v for k, v in ctor_DecisionBoundaryDisplay.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeDecisionBoundaryDisplay[${this.id}] = DecisionBoundaryDisplay(**ctor_DecisionBoundaryDisplay)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeDecisionBoundaryDisplay[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Plot decision boundary given an estimator.\n   */\n  async from_estimator(\n    opts: DecisionBoundaryDisplayFromEstimatorOptions\n  ): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This DecisionBoundaryDisplay instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'DecisionBoundaryDisplay must call init() before from_estimator()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_DecisionBoundaryDisplay_from_estimator = {'estimator': ${\n      opts['estimator'] ?? undefined\n    }, 'X': np.array(${opts['X'] ?? undefined}) if ${\n      opts['X'] !== undefined\n    } else None, 'grid_resolution': ${\n      opts['grid_resolution'] ?? undefined\n    }, 'eps': ${opts['eps'] ?? undefined}, 'plot_method': ${\n      opts['plot_method'] ?? undefined\n    }, 'response_method': ${opts['response_method'] ?? undefined}, 'xlabel': ${\n      opts['xlabel'] ?? undefined\n    }, 'ylabel': ${opts['ylabel'] ?? undefined}, 'ax': ${\n      opts['ax'] ?? undefined\n    }, 'kwargs': ${opts['kwargs'] ?? undefined}}\n\npms_DecisionBoundaryDisplay_from_estimator = {k: v for k, v in pms_DecisionBoundaryDisplay_from_estimator.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_DecisionBoundaryDisplay_from_estimator = bridgeDecisionBoundaryDisplay[${this.id}].from_estimator(**pms_DecisionBoundaryDisplay_from_estimator)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_DecisionBoundaryDisplay_from_estimator.tolist() if hasattr(res_DecisionBoundaryDisplay_from_estimator, 'tolist') else res_DecisionBoundaryDisplay_from_estimator`\n  }\n\n  /**\n    Plot visualization.\n   */\n  async plot(opts: DecisionBoundaryDisplayPlotOptions): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This DecisionBoundaryDisplay instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('DecisionBoundaryDisplay must call init() before plot()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_DecisionBoundaryDisplay_plot = {'plot_method': ${\n      opts['plot_method'] ?? undefined\n    }, 'ax': ${opts['ax'] ?? undefined}, 'xlabel': ${\n      opts['xlabel'] ?? undefined\n    }, 'ylabel': ${opts['ylabel'] ?? undefined}, 'kwargs': ${\n      opts['kwargs'] ?? undefined\n    }}\n\npms_DecisionBoundaryDisplay_plot = {k: v for k, v in pms_DecisionBoundaryDisplay_plot.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_DecisionBoundaryDisplay_plot = bridgeDecisionBoundaryDisplay[${this.id}].plot(**pms_DecisionBoundaryDisplay_plot)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_DecisionBoundaryDisplay_plot.tolist() if hasattr(res_DecisionBoundaryDisplay_plot, 'tolist') else res_DecisionBoundaryDisplay_plot`\n  }\n\n  /**\n    If plot_method is ‘contour’ or ‘contourf’, surface_ is a QuadContourSet. If plot_method is ‘pcolormesh’, surface_ is a QuadMesh.\n   */\n  get surface_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This DecisionBoundaryDisplay instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'DecisionBoundaryDisplay must call init() before accessing surface_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_DecisionBoundaryDisplay_surface_ = bridgeDecisionBoundaryDisplay[${this.id}].surface_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_DecisionBoundaryDisplay_surface_.tolist() if hasattr(attr_DecisionBoundaryDisplay_surface_, 'tolist') else attr_DecisionBoundaryDisplay_surface_`\n    })()\n  }\n\n  /**\n    Axes with confusion matrix.\n   */\n  get ax_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This DecisionBoundaryDisplay instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'DecisionBoundaryDisplay must call init() before accessing ax_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_DecisionBoundaryDisplay_ax_ = bridgeDecisionBoundaryDisplay[${this.id}].ax_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_DecisionBoundaryDisplay_ax_.tolist() if hasattr(attr_DecisionBoundaryDisplay_ax_, 'tolist') else attr_DecisionBoundaryDisplay_ax_`\n    })()\n  }\n\n  /**\n    Figure containing the confusion matrix.\n   */\n  get figure_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This DecisionBoundaryDisplay instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'DecisionBoundaryDisplay must call init() before accessing figure_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_DecisionBoundaryDisplay_figure_ = bridgeDecisionBoundaryDisplay[${this.id}].figure_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_DecisionBoundaryDisplay_figure_.tolist() if hasattr(attr_DecisionBoundaryDisplay_figure_, 'tolist') else attr_DecisionBoundaryDisplay_figure_`\n    })()\n  }\n}\n\nexport interface DecisionBoundaryDisplayOptions {\n  /**\n    First output of meshgrid.\n   */\n  xx0?: NDArray[]\n\n  /**\n    Second output of meshgrid.\n   */\n  xx1?: NDArray[]\n\n  /**\n    Values of the response function.\n   */\n  response?: NDArray[]\n\n  /**\n    Default label to place on x axis.\n   */\n  xlabel?: string\n\n  /**\n    Default label to place on y axis.\n   */\n  ylabel?: string\n}\n\nexport interface DecisionBoundaryDisplayFromEstimatorOptions {\n  /**\n    Trained estimator used to plot the decision boundary.\n   */\n  estimator?: any\n\n  /**\n    Input data that should be only 2-dimensional.\n   */\n  X?: ArrayLike | SparseMatrix[]\n\n  /**\n    Number of grid points to use for plotting decision boundary. Higher values will make the plot look nicer but be slower to render.\n\n    @defaultValue `100`\n   */\n  grid_resolution?: number\n\n  /**\n    Extends the minimum and maximum values of X for evaluating the response function.\n\n    @defaultValue `1`\n   */\n  eps?: number\n\n  /**\n    Plotting method to call when plotting the response. Please refer to the following matplotlib documentation for details: contourf, contour, pcolormesh.\n\n    @defaultValue `'contourf'`\n   */\n  plot_method?: 'contourf' | 'contour' | 'pcolormesh'\n\n  /**\n    Specifies whether to use predict_proba, decision_function, predict as the target response. If set to ‘auto’, the response method is tried in the following order: decision_function, predict_proba, predict. For multiclass problems, predict is selected when response_method=\"auto\".\n\n    @defaultValue `'auto'`\n   */\n  response_method?: 'auto' | 'predict_proba' | 'decision_function' | 'predict'\n\n  /**\n    The label used for the x-axis. If None, an attempt is made to extract a label from X if it is a dataframe, otherwise an empty string is used.\n   */\n  xlabel?: string\n\n  /**\n    The label used for the y-axis. If None, an attempt is made to extract a label from X if it is a dataframe, otherwise an empty string is used.\n   */\n  ylabel?: string\n\n  /**\n    Axes object to plot on. If None, a new figure and axes is created.\n   */\n  ax?: any\n\n  /**\n    Additional keyword arguments to be passed to the plot_method.\n   */\n  kwargs?: any\n}\n\nexport interface DecisionBoundaryDisplayPlotOptions {\n  /**\n    Plotting method to call when plotting the response. Please refer to the following matplotlib documentation for details: contourf, contour, pcolormesh.\n\n    @defaultValue `'contourf'`\n   */\n  plot_method?: 'contourf' | 'contour' | 'pcolormesh'\n\n  /**\n    Axes object to plot on. If None, a new figure and axes is created.\n   */\n  ax?: any\n\n  /**\n    Overwrite the x-axis label.\n   */\n  xlabel?: string\n\n  /**\n    Overwrite the y-axis label.\n   */\n  ylabel?: string\n\n  /**\n    Additional keyword arguments to be passed to the plot_method.\n   */\n  kwargs?: any\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Partial Dependence Plot (PDP).\n\n  This can also display individual partial dependencies which are often referred to as: Individual Condition Expectation (ICE).\n\n  It is recommended to use from_estimator to create a PartialDependenceDisplay. All parameters are stored as attributes.\n\n  Read more in Advanced Plotting With Partial Dependence and the User Guide.\n\n  @see https://scikit-learn.org/stable/modules/generated/sklearn.inspection.PartialDependenceDisplay.html\n */\nexport class PartialDependenceDisplay {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: PartialDependenceDisplayOptions) {\n    this.id = `PartialDependenceDisplay${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PartialDependenceDisplay instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'PartialDependenceDisplay.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.inspection import PartialDependenceDisplay\ntry: bridgePartialDependenceDisplay\nexcept NameError: bridgePartialDependenceDisplay = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_PartialDependenceDisplay = {'pd_results': ${\n      this.opts['pd_results'] ?? undefined\n    }, 'features': ${this.opts['features'] ?? undefined}, 'feature_names': ${\n      this.opts['feature_names'] ?? undefined\n    }, 'target_idx': ${this.opts['target_idx'] ?? undefined}, 'deciles': ${\n      this.opts['deciles'] ?? undefined\n    }, 'pdp_lim': ${this.opts['pdp_lim'] ?? undefined}, 'kind': ${\n      this.opts['kind'] ?? undefined\n    }, 'subsample': ${this.opts['subsample'] ?? undefined}, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }, 'is_categorical': ${this.opts['is_categorical'] ?? undefined}}\n\nctor_PartialDependenceDisplay = {k: v for k, v in ctor_PartialDependenceDisplay.items() if v is not None}`\n\n    await this._py\n      .ex`bridgePartialDependenceDisplay[${this.id}] = PartialDependenceDisplay(**ctor_PartialDependenceDisplay)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgePartialDependenceDisplay[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Partial dependence (PD) and individual conditional expectation (ICE) plots.\n\n    Partial dependence plots, individual conditional expectation plots or an overlay of both of them can be plotted by setting the kind parameter. The len(features) plots are arranged in a grid with n_cols columns. Two-way partial dependence plots are plotted as contour plots. The deciles of the feature values will be shown with tick marks on the x-axes for one-way plots, and on both axes for two-way plots.\n   */\n  async from_estimator(\n    opts: PartialDependenceDisplayFromEstimatorOptions\n  ): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PartialDependenceDisplay instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PartialDependenceDisplay must call init() before from_estimator()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_PartialDependenceDisplay_from_estimator = {'estimator': ${\n      opts['estimator'] ?? undefined\n    }, 'X': np.array(${opts['X'] ?? undefined}) if ${\n      opts['X'] !== undefined\n    } else None, 'features': ${\n      opts['features'] ?? undefined\n    }, 'categorical_features': np.array(${\n      opts['categorical_features'] ?? undefined\n    }) if ${\n      opts['categorical_features'] !== undefined\n    } else None, 'feature_names': np.array(${\n      opts['feature_names'] ?? undefined\n    }) if ${opts['feature_names'] !== undefined} else None, 'target': ${\n      opts['target'] ?? undefined\n    }, 'response_method': ${opts['response_method'] ?? undefined}, 'n_cols': ${\n      opts['n_cols'] ?? undefined\n    }, 'grid_resolution': ${\n      opts['grid_resolution'] ?? undefined\n    }, 'percentiles': ${opts['percentiles'] ?? undefined}, 'method': ${\n      opts['method'] ?? undefined\n    }, 'n_jobs': ${opts['n_jobs'] ?? undefined}, 'verbose': ${\n      opts['verbose'] ?? undefined\n    }, 'line_kw': ${opts['line_kw'] ?? undefined}, 'ice_lines_kw': ${\n      opts['ice_lines_kw'] ?? undefined\n    }, 'pd_line_kw': ${opts['pd_line_kw'] ?? undefined}, 'contour_kw': ${\n      opts['contour_kw'] ?? undefined\n    }, 'ax': ${opts['ax'] ?? undefined}, 'kind': ${\n      opts['kind'] ?? undefined\n    }, 'centered': ${opts['centered'] ?? undefined}, 'subsample': ${\n      opts['subsample'] ?? undefined\n    }, 'random_state': ${opts['random_state'] ?? undefined}}\n\npms_PartialDependenceDisplay_from_estimator = {k: v for k, v in pms_PartialDependenceDisplay_from_estimator.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PartialDependenceDisplay_from_estimator = bridgePartialDependenceDisplay[${this.id}].from_estimator(**pms_PartialDependenceDisplay_from_estimator)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PartialDependenceDisplay_from_estimator.tolist() if hasattr(res_PartialDependenceDisplay_from_estimator, 'tolist') else res_PartialDependenceDisplay_from_estimator`\n  }\n\n  /**\n    Plot partial dependence plots.\n   */\n  async plot(opts: PartialDependenceDisplayPlotOptions): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PartialDependenceDisplay instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PartialDependenceDisplay must call init() before plot()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_PartialDependenceDisplay_plot = {'ax': ${\n      opts['ax'] ?? undefined\n    }, 'n_cols': ${opts['n_cols'] ?? undefined}, 'line_kw': ${\n      opts['line_kw'] ?? undefined\n    }, 'ice_lines_kw': ${opts['ice_lines_kw'] ?? undefined}, 'pd_line_kw': ${\n      opts['pd_line_kw'] ?? undefined\n    }, 'contour_kw': ${opts['contour_kw'] ?? undefined}, 'bar_kw': ${\n      opts['bar_kw'] ?? undefined\n    }, 'heatmap_kw': ${opts['heatmap_kw'] ?? undefined}, 'pdp_lim': ${\n      opts['pdp_lim'] ?? undefined\n    }, 'centered': ${opts['centered'] ?? undefined}}\n\npms_PartialDependenceDisplay_plot = {k: v for k, v in pms_PartialDependenceDisplay_plot.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PartialDependenceDisplay_plot = bridgePartialDependenceDisplay[${this.id}].plot(**pms_PartialDependenceDisplay_plot)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PartialDependenceDisplay_plot.tolist() if hasattr(res_PartialDependenceDisplay_plot, 'tolist') else res_PartialDependenceDisplay_plot`\n  }\n\n  /**\n    If ax is an axes or None, the bounding_ax_ is the axes where the grid of partial dependence plots are drawn. If ax is a list of axes or a numpy array of axes, bounding_ax_ is None.\n   */\n  get bounding_ax_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PartialDependenceDisplay instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PartialDependenceDisplay must call init() before accessing bounding_ax_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PartialDependenceDisplay_bounding_ax_ = bridgePartialDependenceDisplay[${this.id}].bounding_ax_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PartialDependenceDisplay_bounding_ax_.tolist() if hasattr(attr_PartialDependenceDisplay_bounding_ax_, 'tolist') else attr_PartialDependenceDisplay_bounding_ax_`\n    })()\n  }\n\n  /**\n    If ax is an axes or None, axes_[i, j] is the axes on the i-th row and j-th column. If ax is a list of axes, axes_[i] is the i-th item in ax. Elements that are None correspond to a nonexisting axes in that position.\n   */\n  get axes_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PartialDependenceDisplay instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PartialDependenceDisplay must call init() before accessing axes_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PartialDependenceDisplay_axes_ = bridgePartialDependenceDisplay[${this.id}].axes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PartialDependenceDisplay_axes_.tolist() if hasattr(attr_PartialDependenceDisplay_axes_, 'tolist') else attr_PartialDependenceDisplay_axes_`\n    })()\n  }\n\n  /**\n    If ax is an axes or None, lines_[i, j] is the partial dependence curve on the i-th row and j-th column. If ax is a list of axes, lines_[i] is the partial dependence curve corresponding to the i-th item in ax. Elements that are None correspond to a nonexisting axes or an axes that does not include a line plot.\n   */\n  get lines_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PartialDependenceDisplay instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PartialDependenceDisplay must call init() before accessing lines_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PartialDependenceDisplay_lines_ = bridgePartialDependenceDisplay[${this.id}].lines_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PartialDependenceDisplay_lines_.tolist() if hasattr(attr_PartialDependenceDisplay_lines_, 'tolist') else attr_PartialDependenceDisplay_lines_`\n    })()\n  }\n\n  /**\n    If ax is an axes or None, vlines_[i, j] is the line collection representing the x axis deciles of the i-th row and j-th column. If ax is a list of axes, vlines_[i] corresponds to the i-th item in ax. Elements that are None correspond to a nonexisting axes or an axes that does not include a PDP plot.\n   */\n  get deciles_vlines_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PartialDependenceDisplay instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PartialDependenceDisplay must call init() before accessing deciles_vlines_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PartialDependenceDisplay_deciles_vlines_ = bridgePartialDependenceDisplay[${this.id}].deciles_vlines_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PartialDependenceDisplay_deciles_vlines_.tolist() if hasattr(attr_PartialDependenceDisplay_deciles_vlines_, 'tolist') else attr_PartialDependenceDisplay_deciles_vlines_`\n    })()\n  }\n\n  /**\n    If ax is an axes or None, vlines_[i, j] is the line collection representing the y axis deciles of the i-th row and j-th column. If ax is a list of axes, vlines_[i] corresponds to the i-th item in ax. Elements that are None correspond to a nonexisting axes or an axes that does not include a 2-way plot.\n   */\n  get deciles_hlines_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PartialDependenceDisplay instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PartialDependenceDisplay must call init() before accessing deciles_hlines_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PartialDependenceDisplay_deciles_hlines_ = bridgePartialDependenceDisplay[${this.id}].deciles_hlines_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PartialDependenceDisplay_deciles_hlines_.tolist() if hasattr(attr_PartialDependenceDisplay_deciles_hlines_, 'tolist') else attr_PartialDependenceDisplay_deciles_hlines_`\n    })()\n  }\n\n  /**\n    If ax is an axes or None, contours_[i, j] is the partial dependence plot on the i-th row and j-th column. If ax is a list of axes, contours_[i] is the partial dependence plot corresponding to the i-th item in ax. Elements that are None correspond to a nonexisting axes or an axes that does not include a contour plot.\n   */\n  get contours_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PartialDependenceDisplay instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PartialDependenceDisplay must call init() before accessing contours_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PartialDependenceDisplay_contours_ = bridgePartialDependenceDisplay[${this.id}].contours_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PartialDependenceDisplay_contours_.tolist() if hasattr(attr_PartialDependenceDisplay_contours_, 'tolist') else attr_PartialDependenceDisplay_contours_`\n    })()\n  }\n\n  /**\n    If ax is an axes or None, bars_[i, j] is the partial dependence bar plot on the i-th row and j-th column (for a categorical feature). If ax is a list of axes, bars_[i] is the partial dependence bar plot corresponding to the i-th item in ax. Elements that are None correspond to a nonexisting axes or an axes that does not include a bar plot.\n   */\n  get bars_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PartialDependenceDisplay instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PartialDependenceDisplay must call init() before accessing bars_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PartialDependenceDisplay_bars_ = bridgePartialDependenceDisplay[${this.id}].bars_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PartialDependenceDisplay_bars_.tolist() if hasattr(attr_PartialDependenceDisplay_bars_, 'tolist') else attr_PartialDependenceDisplay_bars_`\n    })()\n  }\n\n  /**\n    If ax is an axes or None, heatmaps_[i, j] is the partial dependence heatmap on the i-th row and j-th column (for a pair of categorical features) . If ax is a list of axes, heatmaps_[i] is the partial dependence heatmap corresponding to the i-th item in ax. Elements that are None correspond to a nonexisting axes or an axes that does not include a heatmap.\n   */\n  get heatmaps_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PartialDependenceDisplay instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PartialDependenceDisplay must call init() before accessing heatmaps_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PartialDependenceDisplay_heatmaps_ = bridgePartialDependenceDisplay[${this.id}].heatmaps_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PartialDependenceDisplay_heatmaps_.tolist() if hasattr(attr_PartialDependenceDisplay_heatmaps_, 'tolist') else attr_PartialDependenceDisplay_heatmaps_`\n    })()\n  }\n\n  /**\n    Figure containing partial dependence plots.\n   */\n  get figure_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PartialDependenceDisplay instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PartialDependenceDisplay must call init() before accessing figure_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PartialDependenceDisplay_figure_ = bridgePartialDependenceDisplay[${this.id}].figure_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PartialDependenceDisplay_figure_.tolist() if hasattr(attr_PartialDependenceDisplay_figure_, 'tolist') else attr_PartialDependenceDisplay_figure_`\n    })()\n  }\n}\n\nexport interface PartialDependenceDisplayOptions {\n  /**\n    Results of partial_dependence for features.\n   */\n  pd_results?: any\n\n  /**\n    Indices of features for a given plot. A tuple of one integer will plot a partial dependence curve of one feature. A tuple of two integers will plot a two-way partial dependence curve as a contour plot.\n   */\n  features?: any\n\n  /**\n    Feature names corresponding to the indices in features.\n   */\n  feature_names?: any\n\n  /**\n    In a multiclass setting, specifies the class for which the PDPs should be computed. Note that for binary classification, the positive class (index 1) is always used.\n   */\n  target_idx?: number\n\n  /**\n    Deciles for feature indices in features.\n   */\n  deciles?: any\n\n  /**\n    Global min and max average predictions, such that all plots will have the same scale and y limits. pdp_lim[1] is the global min and max for single partial dependence curves. pdp_lim[2] is the global min and max for two-way partial dependence curves. If None, the limit will be inferred from the global minimum and maximum of all predictions.\n   */\n  pdp_lim?: any\n\n  /**\n    Whether to plot the partial dependence averaged across all the samples in the dataset or one line per sample or both.\n\n    @defaultValue `'average'`\n   */\n  kind?: 'average' | 'individual' | 'both'\n\n  /**\n    Sampling for ICE curves when kind is ‘individual’ or ‘both’. If float, should be between 0.0 and 1.0 and represent the proportion of the dataset to be used to plot ICE curves. If int, represents the maximum absolute number of samples to use.\n\n    Note that the full dataset is still used to calculate partial dependence when kind='both'.\n\n    @defaultValue `1000`\n   */\n  subsample?: number\n\n  /**\n    Controls the randomness of the selected samples when subsamples is not None. See Glossary for details.\n   */\n  random_state?: number\n\n  /**\n    Whether each target feature in features is categorical or not. The list should be same size as features. If None, all features are assumed to be continuous.\n   */\n  is_categorical?: any\n}\n\nexport interface PartialDependenceDisplayFromEstimatorOptions {\n  /**\n    A fitted estimator object implementing predict, predict_proba, or decision_function. Multioutput-multiclass classifiers are not supported.\n   */\n  estimator?: any\n\n  /**\n    X is used to generate a grid of values for the target features (where the partial dependence will be evaluated), and also to generate values for the complement features when the method is 'brute'.\n   */\n  X?: ArrayLike[]\n\n  /**\n    The target features for which to create the PDPs. If features[i] is an integer or a string, a one-way PDP is created; if features[i] is a tuple, a two-way PDP is created (only supported with kind='average'). Each tuple must be of size 2. If any entry is a string, then it must be in feature_names.\n   */\n  features?: string\n\n  /**\n    Indicates the categorical features.\n   */\n  categorical_features?: ArrayLike | number\n\n  /**\n    Name of each feature; feature_names[i] holds the name of the feature with index i. By default, the name of the feature corresponds to their numerical index for NumPy array and their column name for pandas dataframe.\n   */\n  feature_names?: ArrayLike\n\n  /**\n    In a multiclass setting, specifies the class for which the PDPs should be computed. Note that for binary classification, the positive class (index 1) is always used.\n   */\n  target?: number\n\n  /**\n    Specifies whether to use predict_proba or decision_function as the target response. For regressors this parameter is ignored and the response is always the output of predict. By default, predict_proba is tried first and we revert to decision_function if it doesn’t exist. If method is 'recursion', the response is always the output of decision_function.\n\n    @defaultValue `'auto'`\n   */\n  response_method?: 'auto' | 'predict_proba' | 'decision_function'\n\n  /**\n    The maximum number of columns in the grid plot. Only active when ax is a single axis or None.\n\n    @defaultValue `3`\n   */\n  n_cols?: number\n\n  /**\n    The number of equally spaced points on the axes of the plots, for each target feature.\n\n    @defaultValue `100`\n   */\n  grid_resolution?: number\n\n  /**\n    The lower and upper percentile used to create the extreme values for the PDP axes. Must be in [0, 1].\n   */\n  percentiles?: any\n\n  /**\n    The method used to calculate the averaged predictions:\n\n    @defaultValue `'auto'`\n   */\n  method?: string\n\n  /**\n    The number of CPUs to use to compute the partial dependences. Computation is parallelized over features specified by the features parameter.\n\n    None means 1 unless in a joblib.parallel_backend context. -1 means using all processors. See Glossary for more details.\n   */\n  n_jobs?: number\n\n  /**\n    Verbose output during PD computations.\n\n    @defaultValue `0`\n   */\n  verbose?: number\n\n  /**\n    Dict with keywords passed to the matplotlib.pyplot.plot call. For one-way partial dependence plots. It can be used to define common properties for both ice_lines_kw and pdp_line_kw.\n   */\n  line_kw?: any\n\n  /**\n    Dictionary with keywords passed to the matplotlib.pyplot.plot call. For ICE lines in the one-way partial dependence plots. The key value pairs defined in ice_lines_kw takes priority over line_kw.\n   */\n  ice_lines_kw?: any\n\n  /**\n    Dictionary with keywords passed to the matplotlib.pyplot.plot call. For partial dependence in one-way partial dependence plots. The key value pairs defined in pd_line_kw takes priority over line_kw.\n   */\n  pd_line_kw?: any\n\n  /**\n    Dict with keywords passed to the matplotlib.pyplot.contourf call. For two-way partial dependence plots.\n   */\n  contour_kw?: any\n\n  /**\n    If a single axis is passed in, it is treated as a bounding axes and a grid of partial dependence plots will be drawn within these bounds. The n_cols parameter controls the number of columns in the grid.\n   */\n  ax?: any\n\n  /**\n    Whether to plot the partial dependence averaged across all the samples in the dataset or one line per sample or both.\n\n    @defaultValue `'average'`\n   */\n  kind?: 'average' | 'individual' | 'both'\n\n  /**\n    If True, the ICE and PD lines will start at the origin of the y-axis. By default, no centering is done.\n\n    @defaultValue `false`\n   */\n  centered?: boolean\n\n  /**\n    Sampling for ICE curves when kind is ‘individual’ or ‘both’. If float, should be between 0.0 and 1.0 and represent the proportion of the dataset to be used to plot ICE curves. If int, represents the absolute number samples to use.\n\n    Note that the full dataset is still used to calculate averaged partial dependence when kind='both'.\n\n    @defaultValue `1000`\n   */\n  subsample?: number\n\n  /**\n    Controls the randomness of the selected samples when subsamples is not None and kind is either 'both' or 'individual'. See Glossary for details.\n   */\n  random_state?: number\n}\n\nexport interface PartialDependenceDisplayPlotOptions {\n  /**\n    and a grid of partial dependence plots will be drawn within these bounds. The n_cols parameter controls the number of columns in the grid.\n   */\n  ax?: any\n\n  /**\n    The maximum number of columns in the grid plot. Only active when ax is a single axes or None.\n\n    @defaultValue `3`\n   */\n  n_cols?: number\n\n  /**\n    Dict with keywords passed to the matplotlib.pyplot.plot call. For one-way partial dependence plots.\n   */\n  line_kw?: any\n\n  /**\n    Dictionary with keywords passed to the matplotlib.pyplot.plot call. For ICE lines in the one-way partial dependence plots. The key value pairs defined in ice_lines_kw takes priority over line_kw.\n   */\n  ice_lines_kw?: any\n\n  /**\n    Dictionary with keywords passed to the matplotlib.pyplot.plot call. For partial dependence in one-way partial dependence plots. The key value pairs defined in pd_line_kw takes priority over line_kw.\n   */\n  pd_line_kw?: any\n\n  /**\n    Dict with keywords passed to the matplotlib.pyplot.contourf call for two-way partial dependence plots.\n   */\n  contour_kw?: any\n\n  /**\n    Dict with keywords passed to the matplotlib.pyplot.bar call for one-way categorical partial dependence plots.\n   */\n  bar_kw?: any\n\n  /**\n    Dict with keywords passed to the matplotlib.pyplot.imshow call for two-way categorical partial dependence plots.\n   */\n  heatmap_kw?: any\n\n  /**\n    Global min and max average predictions, such that all plots will have the same scale and y limits. pdp_lim[1] is the global min and max for single partial dependence curves. pdp_lim[2] is the global min and max for two-way partial dependence curves. If None (default), the limit will be inferred from the global minimum and maximum of all predictions.\n   */\n  pdp_lim?: any\n\n  /**\n    If True, the ICE and PD lines will start at the origin of the y-axis. By default, no centering is done.\n\n    @defaultValue `false`\n   */\n  centered?: boolean\n}\n"],"mappings":"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","names":["crypto"]}