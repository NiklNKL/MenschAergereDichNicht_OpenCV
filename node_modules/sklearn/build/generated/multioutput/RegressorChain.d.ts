import { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types';
/**
  A multi-label model that arranges regressions into a chain.

  Each model makes a prediction in the order specified by the chain using all of the available features provided to the model plus the predictions of models that are earlier in the chain.

  @see https://scikit-learn.org/stable/modules/generated/sklearn.multioutput.RegressorChain.html
 */
export declare class RegressorChain {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: RegressorChainOptions);
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Fit the model to data matrix X and targets Y.
     */
    fit(opts: RegressorChainFitOptions): Promise<any>;
    /**
      Predict on the data matrix X using the ClassifierChain model.
     */
    predict(opts: RegressorChainPredictOptions): Promise<ArrayLike[]>;
    /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \(R^2\) is defined as \((1 - \frac{u}{v})\), where \(u\) is the residual sum of squares ((y_true - y_pred)** 2).sum() and \(v\) is the total sum of squares ((y_true - y_true.mean()) ** 2).sum(). The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of y, disregarding the input features, would get a \(R^2\) score of 0.0.
     */
    score(opts: RegressorChainScoreOptions): Promise<number>;
    /**
      A list of clones of base_estimator.
     */
    get estimators_(): Promise<any[]>;
    /**
      The order of labels in the classifier chain.
     */
    get order_(): Promise<any[]>;
    /**
      Number of features seen during fit. Only defined if the underlying base_estimator exposes such an attribute when fit.
     */
    get n_features_in_(): Promise<number>;
    /**
      Names of features seen during fit. Defined only when X has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
}
export interface RegressorChainOptions {
    /**
      The base estimator from which the regressor chain is built.
     */
    base_estimator?: any;
    /**
      If None, the order will be determined by the order of columns in the label matrix Y.:
     */
    order?: ArrayLike | 'random';
    /**
      Determines whether to use cross validated predictions or true labels for the results of previous estimators in the chain. Possible inputs for cv are:
     */
    cv?: number;
    /**
      If order='random', determines random number generation for the chain order. In addition, it controls the random seed given at each base_estimator at each chaining iteration. Thus, it is only used when base_estimator exposes a random_state. Pass an int for reproducible output across multiple function calls. See Glossary.
     */
    random_state?: number;
    /**
      If True, chain progress is output as each model is completed.
  
      @defaultValue `false`
     */
    verbose?: boolean;
}
export interface RegressorChainFitOptions {
    /**
      The input data.
     */
    X?: ArrayLike | SparseMatrix[];
    /**
      The target values.
     */
    Y?: ArrayLike[];
    /**
      Parameters passed to the fit method at each step of the regressor chain.
     */
    fit_params?: any;
}
export interface RegressorChainPredictOptions {
    /**
      The input data.
     */
    X?: ArrayLike | SparseMatrix[];
}
export interface RegressorChainScoreOptions {
    /**
      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape (n_samples, n_samples_fitted), where n_samples_fitted is the number of samples used in the fitting for the estimator.
     */
    X?: ArrayLike[];
    /**
      True values for X.
     */
    y?: ArrayLike;
    /**
      Sample weights.
     */
    sample_weight?: ArrayLike;
}
//# sourceMappingURL=RegressorChain.d.ts.map