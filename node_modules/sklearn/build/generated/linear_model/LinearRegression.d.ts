import { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types';
/**
  Ordinary least squares Linear Regression.

  LinearRegression fits a linear model with coefficients w = (w1, …, wp) to minimize the residual sum of squares between the observed targets in the dataset, and the targets predicted by the linear approximation.

  @see https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html
 */
export declare class LinearRegression {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: LinearRegressionOptions);
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Fit linear model.
     */
    fit(opts: LinearRegressionFitOptions): Promise<any>;
    /**
      Predict using the linear model.
     */
    predict(opts: LinearRegressionPredictOptions): Promise<any>;
    /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \(R^2\) is defined as \((1 - \frac{u}{v})\), where \(u\) is the residual sum of squares ((y_true - y_pred)** 2).sum() and \(v\) is the total sum of squares ((y_true - y_true.mean()) ** 2).sum(). The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of y, disregarding the input features, would get a \(R^2\) score of 0.0.
     */
    score(opts: LinearRegressionScoreOptions): Promise<number>;
    /**
      Estimated coefficients for the linear regression problem. If multiple targets are passed during the fit (y 2D), this is a 2D array of shape (n_targets, n_features), while if only one target is passed, this is a 1D array of length n_features.
     */
    get coef_(): Promise<any[]>;
    /**
      Rank of matrix X. Only available when X is dense.
     */
    get rank_(): Promise<number>;
    /**
      Singular values of X. Only available when X is dense.
     */
    get singular_(): Promise<any[]>;
    /**
      Independent term in the linear model. Set to 0.0 if fit_intercept = False.
     */
    get intercept_(): Promise<number | any[]>;
    /**
      Number of features seen during fit.
     */
    get n_features_in_(): Promise<number>;
    /**
      Names of features seen during fit. Defined only when X has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
}
export interface LinearRegressionOptions {
    /**
      Whether to calculate the intercept for this model. If set to False, no intercept will be used in calculations (i.e. data is expected to be centered).
  
      @defaultValue `true`
     */
    fit_intercept?: boolean;
    /**
      If True, X will be copied; else, it may be overwritten.
  
      @defaultValue `true`
     */
    copy_X?: boolean;
    /**
      The number of jobs to use for the computation. This will only provide speedup in case of sufficiently large problems, that is if firstly n_targets > 1 and secondly X is sparse or if positive is set to True. None means 1 unless in a joblib.parallel_backend context. -1 means using all processors. See Glossary for more details.
     */
    n_jobs?: number;
    /**
      When set to True, forces the coefficients to be positive. This option is only supported for dense arrays.
  
      @defaultValue `false`
     */
    positive?: boolean;
}
export interface LinearRegressionFitOptions {
    /**
      Training data.
     */
    X?: ArrayLike | SparseMatrix[];
    /**
      Target values. Will be cast to X’s dtype if necessary.
     */
    y?: ArrayLike;
    /**
      Individual weights for each sample.
     */
    sample_weight?: ArrayLike;
}
export interface LinearRegressionPredictOptions {
    /**
      Samples.
     */
    X?: ArrayLike | SparseMatrix;
}
export interface LinearRegressionScoreOptions {
    /**
      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape (n_samples, n_samples_fitted), where n_samples_fitted is the number of samples used in the fitting for the estimator.
     */
    X?: ArrayLike[];
    /**
      True values for X.
     */
    y?: ArrayLike;
    /**
      Sample weights.
     */
    sample_weight?: ArrayLike;
}
//# sourceMappingURL=LinearRegression.d.ts.map