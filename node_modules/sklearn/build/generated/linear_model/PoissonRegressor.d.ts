import { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types';
/**
  Generalized Linear Model with a Poisson distribution.

  This regressor uses the ‘log’ link function.

  @see https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.PoissonRegressor.html
 */
export declare class PoissonRegressor {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: PoissonRegressorOptions);
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Fit a Generalized Linear Model.
     */
    fit(opts: PoissonRegressorFitOptions): Promise<any>;
    /**
      Predict using GLM with feature matrix X.
     */
    predict(opts: PoissonRegressorPredictOptions): Promise<any[]>;
    /**
      Compute D^2, the percentage of deviance explained.
  
      D^2 is a generalization of the coefficient of determination R^2. R^2 uses squared error and D^2 uses the deviance of this GLM, see the User Guide.
  
      D^2 is defined as \(D^2 = 1-\frac{D(y_{true},y_{pred})}{D_{null}}\), \(D_{null}\) is the null deviance, i.e. the deviance of a model with intercept alone, which corresponds to \(y_{pred} = \bar{y}\). The mean \(\bar{y}\) is averaged by sample_weight. Best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse).
     */
    score(opts: PoissonRegressorScoreOptions): Promise<number>;
    /**
      Estimated coefficients for the linear predictor (X @ coef_ + intercept_) in the GLM.
     */
    get coef_(): Promise<any[]>;
    /**
      Intercept (a.k.a. bias) added to linear predictor.
     */
    get intercept_(): Promise<number>;
    /**
      Number of features seen during fit.
     */
    get n_features_in_(): Promise<number>;
    /**
      Names of features seen during fit. Defined only when X has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
    /**
      Actual number of iterations used in the solver.
     */
    get n_iter_(): Promise<number>;
}
export interface PoissonRegressorOptions {
    /**
      Constant that multiplies the L2 penalty term and determines the regularization strength. alpha = 0 is equivalent to unpenalized GLMs. In this case, the design matrix X must have full column rank (no collinearities). Values of alpha must be in the range [0.0, inf).
  
      @defaultValue `1`
     */
    alpha?: number;
    /**
      Specifies if a constant (a.k.a. bias or intercept) should be added to the linear predictor (X @ coef + intercept).
  
      @defaultValue `true`
     */
    fit_intercept?: boolean;
    /**
      Algorithm to use in the optimization problem:
  
      @defaultValue `'lbfgs'`
     */
    solver?: 'lbfgs' | 'newton-cholesky';
    /**
      The maximal number of iterations for the solver. Values must be in the range [1, inf).
  
      @defaultValue `100`
     */
    max_iter?: number;
    /**
      Stopping criterion. For the lbfgs solver, the iteration will stop when max{|g_j|, j = 1, ..., d} <= tol where g_j is the j-th component of the gradient (derivative) of the objective function. Values must be in the range (0.0, inf).
  
      @defaultValue `0.0001`
     */
    tol?: number;
    /**
      If set to True, reuse the solution of the previous call to fit as initialization for coef_ and intercept_ .
  
      @defaultValue `false`
     */
    warm_start?: boolean;
    /**
      For the lbfgs solver set verbose to any positive number for verbosity. Values must be in the range [0, inf).
  
      @defaultValue `0`
     */
    verbose?: number;
}
export interface PoissonRegressorFitOptions {
    /**
      Training data.
     */
    X?: ArrayLike | SparseMatrix[];
    /**
      Target values.
     */
    y?: ArrayLike;
    /**
      Sample weights.
     */
    sample_weight?: ArrayLike;
}
export interface PoissonRegressorPredictOptions {
    /**
      Samples.
     */
    X?: ArrayLike | SparseMatrix[];
}
export interface PoissonRegressorScoreOptions {
    /**
      Test samples.
     */
    X?: ArrayLike | SparseMatrix[];
    /**
      True values of target.
     */
    y?: ArrayLike;
    /**
      Sample weights.
     */
    sample_weight?: ArrayLike;
}
//# sourceMappingURL=PoissonRegressor.d.ts.map