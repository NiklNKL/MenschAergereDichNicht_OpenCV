import { PythonBridge, NDArray, ArrayLike } from '@/sklearn/types';
/**
  Label Propagation classifier.

  @see https://scikit-learn.org/stable/modules/generated/sklearn.semi_supervised.LabelPropagation.html
 */
export declare class LabelPropagation {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: LabelPropagationOptions);
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Fit a semi-supervised label propagation model to X.
     */
    fit(opts: LabelPropagationFitOptions): Promise<any>;
    /**
      Perform inductive inference across the model.
     */
    predict(opts: LabelPropagationPredictOptions): Promise<NDArray>;
    /**
      Predict probability for each possible outcome.
  
      Compute the probability estimates for each single sample in X and each possible outcome seen during training (categorical distribution).
     */
    predict_proba(opts: LabelPropagationPredictProbaOptions): Promise<NDArray[]>;
    /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
    score(opts: LabelPropagationScoreOptions): Promise<number>;
    /**
      Input array.
     */
    get X_(): Promise<NDArray[]>;
    /**
      The distinct labels used in classifying instances.
     */
    get classes_(): Promise<NDArray>;
    /**
      Categorical distribution for each item.
     */
    get label_distributions_(): Promise<NDArray[]>;
    /**
      Label assigned to each item during fit.
     */
    get transduction_(): Promise<NDArray>;
    /**
      Number of features seen during fit.
     */
    get n_features_in_(): Promise<number>;
    /**
      Names of features seen during fit. Defined only when X has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
    /**
      Number of iterations run.
     */
    get n_iter_(): Promise<number>;
}
export interface LabelPropagationOptions {
    /**
      String identifier for kernel function to use or the kernel function itself. Only ‘rbf’ and ‘knn’ strings are valid inputs. The function passed should take two inputs, each of shape (n_samples, n_features), and return a (n_samples, n_samples) shaped weight matrix.
  
      @defaultValue `'rbf'`
     */
    kernel?: 'knn' | 'rbf';
    /**
      Parameter for rbf kernel.
  
      @defaultValue `20`
     */
    gamma?: number;
    /**
      Parameter for knn kernel which need to be strictly positive.
  
      @defaultValue `7`
     */
    n_neighbors?: number;
    /**
      Change maximum number of iterations allowed.
  
      @defaultValue `1000`
     */
    max_iter?: number;
    /**
      Convergence tolerance: threshold to consider the system at steady state.
     */
    tol?: number;
    /**
      The number of parallel jobs to run. None means 1 unless in a joblib.parallel_backend context. -1 means using all processors. See Glossary for more details.
     */
    n_jobs?: number;
}
export interface LabelPropagationFitOptions {
    /**
      Training data, where n_samples is the number of samples and n_features is the number of features.
     */
    X?: ArrayLike[];
    /**
      Target class values with unlabeled points marked as -1. All unlabeled samples will be transductively assigned labels internally, which are stored in transduction_.
     */
    y?: ArrayLike;
}
export interface LabelPropagationPredictOptions {
    /**
      The data matrix.
     */
    X?: ArrayLike[];
}
export interface LabelPropagationPredictProbaOptions {
    /**
      The data matrix.
     */
    X?: ArrayLike[];
}
export interface LabelPropagationScoreOptions {
    /**
      Test samples.
     */
    X?: ArrayLike[];
    /**
      True labels for X.
     */
    y?: ArrayLike;
    /**
      Sample weights.
     */
    sample_weight?: ArrayLike;
}
//# sourceMappingURL=LabelPropagation.d.ts.map