{"version":3,"sources":["../../../src/generated/semi_supervised/LabelSpreading.ts","../../../src/generated/semi_supervised/SelfTrainingClassifier.ts","../../../src/generated/semi_supervised/LabelPropagation.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  LabelSpreading model for semi-supervised learning.\n\n  This model is similar to the basic Label Propagation algorithm, but uses affinity matrix based on the normalized graph Laplacian and soft clamping across the labels.\n\n  @see https://scikit-learn.org/stable/modules/generated/sklearn.semi_supervised.LabelSpreading.html\n */\nexport class LabelSpreading {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: LabelSpreadingOptions) {\n    this.id = `LabelSpreading${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This LabelSpreading instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('LabelSpreading.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.semi_supervised import LabelSpreading\ntry: bridgeLabelSpreading\nexcept NameError: bridgeLabelSpreading = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_LabelSpreading = {'kernel': ${\n      this.opts['kernel'] ?? undefined\n    }, 'gamma': ${this.opts['gamma'] ?? undefined}, 'n_neighbors': ${\n      this.opts['n_neighbors'] ?? undefined\n    }, 'alpha': ${this.opts['alpha'] ?? undefined}, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'tol': ${this.opts['tol'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }}\n\nctor_LabelSpreading = {k: v for k, v in ctor_LabelSpreading.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeLabelSpreading[${this.id}] = LabelSpreading(**ctor_LabelSpreading)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeLabelSpreading[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit a semi-supervised label propagation model to X.\n\n    The input samples (labeled and unlabeled) are provided by matrix X, and target labels are provided by matrix y. We conventionally apply the label -1 to unlabeled samples in matrix y in a semi-supervised classification.\n   */\n  async fit(opts: LabelSpreadingFitOptions): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LabelSpreading instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelSpreading must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelSpreading_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_LabelSpreading_fit = {k: v for k, v in pms_LabelSpreading_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelSpreading_fit = bridgeLabelSpreading[${this.id}].fit(**pms_LabelSpreading_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelSpreading_fit.tolist() if hasattr(res_LabelSpreading_fit, 'tolist') else res_LabelSpreading_fit`\n  }\n\n  /**\n    Perform inductive inference across the model.\n   */\n  async predict(opts: LabelSpreadingPredictOptions): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LabelSpreading instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelSpreading must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelSpreading_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_LabelSpreading_predict = {k: v for k, v in pms_LabelSpreading_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelSpreading_predict = bridgeLabelSpreading[${this.id}].predict(**pms_LabelSpreading_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelSpreading_predict.tolist() if hasattr(res_LabelSpreading_predict, 'tolist') else res_LabelSpreading_predict`\n  }\n\n  /**\n    Predict probability for each possible outcome.\n\n    Compute the probability estimates for each single sample in X and each possible outcome seen during training (categorical distribution).\n   */\n  async predict_proba(\n    opts: LabelSpreadingPredictProbaOptions\n  ): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This LabelSpreading instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelSpreading must call init() before predict_proba()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelSpreading_predict_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_LabelSpreading_predict_proba = {k: v for k, v in pms_LabelSpreading_predict_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelSpreading_predict_proba = bridgeLabelSpreading[${this.id}].predict_proba(**pms_LabelSpreading_predict_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelSpreading_predict_proba.tolist() if hasattr(res_LabelSpreading_predict_proba, 'tolist') else res_LabelSpreading_predict_proba`\n  }\n\n  /**\n    Return the mean accuracy on the given test data and labels.\n\n    In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.\n   */\n  async score(opts: LabelSpreadingScoreOptions): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LabelSpreading instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelSpreading must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelSpreading_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_LabelSpreading_score = {k: v for k, v in pms_LabelSpreading_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelSpreading_score = bridgeLabelSpreading[${this.id}].score(**pms_LabelSpreading_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelSpreading_score.tolist() if hasattr(res_LabelSpreading_score, 'tolist') else res_LabelSpreading_score`\n  }\n\n  /**\n    Input array.\n   */\n  get X_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This LabelSpreading instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelSpreading must call init() before accessing X_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelSpreading_X_ = bridgeLabelSpreading[${this.id}].X_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelSpreading_X_.tolist() if hasattr(attr_LabelSpreading_X_, 'tolist') else attr_LabelSpreading_X_`\n    })()\n  }\n\n  /**\n    The distinct labels used in classifying instances.\n   */\n  get classes_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LabelSpreading instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelSpreading must call init() before accessing classes_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelSpreading_classes_ = bridgeLabelSpreading[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelSpreading_classes_.tolist() if hasattr(attr_LabelSpreading_classes_, 'tolist') else attr_LabelSpreading_classes_`\n    })()\n  }\n\n  /**\n    Categorical distribution for each item.\n   */\n  get label_distributions_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This LabelSpreading instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelSpreading must call init() before accessing label_distributions_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelSpreading_label_distributions_ = bridgeLabelSpreading[${this.id}].label_distributions_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelSpreading_label_distributions_.tolist() if hasattr(attr_LabelSpreading_label_distributions_, 'tolist') else attr_LabelSpreading_label_distributions_`\n    })()\n  }\n\n  /**\n    Label assigned to each item during fit.\n   */\n  get transduction_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LabelSpreading instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelSpreading must call init() before accessing transduction_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelSpreading_transduction_ = bridgeLabelSpreading[${this.id}].transduction_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelSpreading_transduction_.tolist() if hasattr(attr_LabelSpreading_transduction_, 'tolist') else attr_LabelSpreading_transduction_`\n    })()\n  }\n\n  /**\n    Number of features seen during fit.\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LabelSpreading instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelSpreading must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelSpreading_n_features_in_ = bridgeLabelSpreading[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelSpreading_n_features_in_.tolist() if hasattr(attr_LabelSpreading_n_features_in_, 'tolist') else attr_LabelSpreading_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during fit. Defined only when X has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LabelSpreading instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelSpreading must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelSpreading_feature_names_in_ = bridgeLabelSpreading[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelSpreading_feature_names_in_.tolist() if hasattr(attr_LabelSpreading_feature_names_in_, 'tolist') else attr_LabelSpreading_feature_names_in_`\n    })()\n  }\n\n  /**\n    Number of iterations run.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LabelSpreading instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelSpreading must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelSpreading_n_iter_ = bridgeLabelSpreading[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelSpreading_n_iter_.tolist() if hasattr(attr_LabelSpreading_n_iter_, 'tolist') else attr_LabelSpreading_n_iter_`\n    })()\n  }\n}\n\nexport interface LabelSpreadingOptions {\n  /**\n    String identifier for kernel function to use or the kernel function itself. Only ‘rbf’ and ‘knn’ strings are valid inputs. The function passed should take two inputs, each of shape (n_samples, n_features), and return a (n_samples, n_samples) shaped weight matrix.\n\n    @defaultValue `'rbf'`\n   */\n  kernel?: 'knn' | 'rbf'\n\n  /**\n    Parameter for rbf kernel.\n\n    @defaultValue `20`\n   */\n  gamma?: number\n\n  /**\n    Parameter for knn kernel which is a strictly positive integer.\n\n    @defaultValue `7`\n   */\n  n_neighbors?: number\n\n  /**\n    Clamping factor. A value in (0, 1) that specifies the relative amount that an instance should adopt the information from its neighbors as opposed to its initial label. alpha=0 means keeping the initial label information; alpha=1 means replacing all initial information.\n\n    @defaultValue `0.2`\n   */\n  alpha?: number\n\n  /**\n    Maximum number of iterations allowed.\n\n    @defaultValue `30`\n   */\n  max_iter?: number\n\n  /**\n    Convergence tolerance: threshold to consider the system at steady state.\n\n    @defaultValue `0.001`\n   */\n  tol?: number\n\n  /**\n    The number of parallel jobs to run. None means 1 unless in a joblib.parallel_backend context. -1 means using all processors. See Glossary for more details.\n   */\n  n_jobs?: number\n}\n\nexport interface LabelSpreadingFitOptions {\n  /**\n    Training data, where n_samples is the number of samples and n_features is the number of features.\n   */\n  X?: ArrayLike[]\n\n  /**\n    Target class values with unlabeled points marked as -1. All unlabeled samples will be transductively assigned labels internally, which are stored in transduction_.\n   */\n  y?: ArrayLike\n}\n\nexport interface LabelSpreadingPredictOptions {\n  /**\n    The data matrix.\n   */\n  X?: ArrayLike[]\n}\n\nexport interface LabelSpreadingPredictProbaOptions {\n  /**\n    The data matrix.\n   */\n  X?: ArrayLike[]\n}\n\nexport interface LabelSpreadingScoreOptions {\n  /**\n    Test samples.\n   */\n  X?: ArrayLike[]\n\n  /**\n    True labels for X.\n   */\n  y?: ArrayLike\n\n  /**\n    Sample weights.\n   */\n  sample_weight?: ArrayLike\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Self-training classifier.\n\n  This metaestimator allows a given supervised classifier to function as a semi-supervised classifier, allowing it to learn from unlabeled data. It does this by iteratively predicting pseudo-labels for the unlabeled data and adding them to the training set.\n\n  The classifier will continue iterating until either max_iter is reached, or no pseudo-labels were added to the training set in the previous iteration.\n\n  @see https://scikit-learn.org/stable/modules/generated/sklearn.semi_supervised.SelfTrainingClassifier.html\n */\nexport class SelfTrainingClassifier {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: SelfTrainingClassifierOptions) {\n    this.id = `SelfTrainingClassifier${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'SelfTrainingClassifier.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.semi_supervised import SelfTrainingClassifier\ntry: bridgeSelfTrainingClassifier\nexcept NameError: bridgeSelfTrainingClassifier = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_SelfTrainingClassifier = {'base_estimator': ${\n      this.opts['base_estimator'] ?? undefined\n    }, 'threshold': ${this.opts['threshold'] ?? undefined}, 'criterion': ${\n      this.opts['criterion'] ?? undefined\n    }, 'k_best': ${this.opts['k_best'] ?? undefined}, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}}\n\nctor_SelfTrainingClassifier = {k: v for k, v in ctor_SelfTrainingClassifier.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeSelfTrainingClassifier[${this.id}] = SelfTrainingClassifier(**ctor_SelfTrainingClassifier)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeSelfTrainingClassifier[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Call decision function of the base_estimator.\n   */\n  async decision_function(\n    opts: SelfTrainingClassifierDecisionFunctionOptions\n  ): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before decision_function()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SelfTrainingClassifier_decision_function = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SelfTrainingClassifier_decision_function = {k: v for k, v in pms_SelfTrainingClassifier_decision_function.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelfTrainingClassifier_decision_function = bridgeSelfTrainingClassifier[${this.id}].decision_function(**pms_SelfTrainingClassifier_decision_function)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelfTrainingClassifier_decision_function.tolist() if hasattr(res_SelfTrainingClassifier_decision_function, 'tolist') else res_SelfTrainingClassifier_decision_function`\n  }\n\n  /**\n    Fit self-training classifier using X, y as training data.\n   */\n  async fit(opts: SelfTrainingClassifierFitOptions): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelfTrainingClassifier must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelfTrainingClassifier_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_SelfTrainingClassifier_fit = {k: v for k, v in pms_SelfTrainingClassifier_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelfTrainingClassifier_fit = bridgeSelfTrainingClassifier[${this.id}].fit(**pms_SelfTrainingClassifier_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelfTrainingClassifier_fit.tolist() if hasattr(res_SelfTrainingClassifier_fit, 'tolist') else res_SelfTrainingClassifier_fit`\n  }\n\n  /**\n    Predict the classes of X.\n   */\n  async predict(opts: SelfTrainingClassifierPredictOptions): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before predict()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelfTrainingClassifier_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SelfTrainingClassifier_predict = {k: v for k, v in pms_SelfTrainingClassifier_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelfTrainingClassifier_predict = bridgeSelfTrainingClassifier[${this.id}].predict(**pms_SelfTrainingClassifier_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelfTrainingClassifier_predict.tolist() if hasattr(res_SelfTrainingClassifier_predict, 'tolist') else res_SelfTrainingClassifier_predict`\n  }\n\n  /**\n    Predict log probability for each possible outcome.\n   */\n  async predict_log_proba(\n    opts: SelfTrainingClassifierPredictLogProbaOptions\n  ): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before predict_log_proba()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SelfTrainingClassifier_predict_log_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SelfTrainingClassifier_predict_log_proba = {k: v for k, v in pms_SelfTrainingClassifier_predict_log_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelfTrainingClassifier_predict_log_proba = bridgeSelfTrainingClassifier[${this.id}].predict_log_proba(**pms_SelfTrainingClassifier_predict_log_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelfTrainingClassifier_predict_log_proba.tolist() if hasattr(res_SelfTrainingClassifier_predict_log_proba, 'tolist') else res_SelfTrainingClassifier_predict_log_proba`\n  }\n\n  /**\n    Predict probability for each possible outcome.\n   */\n  async predict_proba(\n    opts: SelfTrainingClassifierPredictProbaOptions\n  ): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before predict_proba()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SelfTrainingClassifier_predict_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SelfTrainingClassifier_predict_proba = {k: v for k, v in pms_SelfTrainingClassifier_predict_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelfTrainingClassifier_predict_proba = bridgeSelfTrainingClassifier[${this.id}].predict_proba(**pms_SelfTrainingClassifier_predict_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelfTrainingClassifier_predict_proba.tolist() if hasattr(res_SelfTrainingClassifier_predict_proba, 'tolist') else res_SelfTrainingClassifier_predict_proba`\n  }\n\n  /**\n    Call score on the base_estimator.\n   */\n  async score(opts: SelfTrainingClassifierScoreOptions): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelfTrainingClassifier must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelfTrainingClassifier_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_SelfTrainingClassifier_score = {k: v for k, v in pms_SelfTrainingClassifier_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelfTrainingClassifier_score = bridgeSelfTrainingClassifier[${this.id}].score(**pms_SelfTrainingClassifier_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelfTrainingClassifier_score.tolist() if hasattr(res_SelfTrainingClassifier_score, 'tolist') else res_SelfTrainingClassifier_score`\n  }\n\n  /**\n    The fitted estimator.\n   */\n  get base_estimator_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before accessing base_estimator_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelfTrainingClassifier_base_estimator_ = bridgeSelfTrainingClassifier[${this.id}].base_estimator_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelfTrainingClassifier_base_estimator_.tolist() if hasattr(attr_SelfTrainingClassifier_base_estimator_, 'tolist') else attr_SelfTrainingClassifier_base_estimator_`\n    })()\n  }\n\n  /**\n    Class labels for each output. (Taken from the trained base_estimator_).\n   */\n  get classes_(): Promise<NDArray | any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before accessing classes_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelfTrainingClassifier_classes_ = bridgeSelfTrainingClassifier[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelfTrainingClassifier_classes_.tolist() if hasattr(attr_SelfTrainingClassifier_classes_, 'tolist') else attr_SelfTrainingClassifier_classes_`\n    })()\n  }\n\n  /**\n    The labels used for the final fit of the classifier, including pseudo-labels added during fit.\n   */\n  get transduction_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before accessing transduction_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelfTrainingClassifier_transduction_ = bridgeSelfTrainingClassifier[${this.id}].transduction_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelfTrainingClassifier_transduction_.tolist() if hasattr(attr_SelfTrainingClassifier_transduction_, 'tolist') else attr_SelfTrainingClassifier_transduction_`\n    })()\n  }\n\n  /**\n    The iteration in which each sample was labeled. When a sample has iteration 0, the sample was already labeled in the original dataset. When a sample has iteration -1, the sample was not labeled in any iteration.\n   */\n  get labeled_iter_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before accessing labeled_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelfTrainingClassifier_labeled_iter_ = bridgeSelfTrainingClassifier[${this.id}].labeled_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelfTrainingClassifier_labeled_iter_.tolist() if hasattr(attr_SelfTrainingClassifier_labeled_iter_, 'tolist') else attr_SelfTrainingClassifier_labeled_iter_`\n    })()\n  }\n\n  /**\n    Number of features seen during fit.\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelfTrainingClassifier_n_features_in_ = bridgeSelfTrainingClassifier[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelfTrainingClassifier_n_features_in_.tolist() if hasattr(attr_SelfTrainingClassifier_n_features_in_, 'tolist') else attr_SelfTrainingClassifier_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during fit. Defined only when X has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelfTrainingClassifier_feature_names_in_ = bridgeSelfTrainingClassifier[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelfTrainingClassifier_feature_names_in_.tolist() if hasattr(attr_SelfTrainingClassifier_feature_names_in_, 'tolist') else attr_SelfTrainingClassifier_feature_names_in_`\n    })()\n  }\n\n  /**\n    The number of rounds of self-training, that is the number of times the base estimator is fitted on relabeled variants of the training set.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelfTrainingClassifier_n_iter_ = bridgeSelfTrainingClassifier[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelfTrainingClassifier_n_iter_.tolist() if hasattr(attr_SelfTrainingClassifier_n_iter_, 'tolist') else attr_SelfTrainingClassifier_n_iter_`\n    })()\n  }\n\n  /**\n    The reason that fitting was stopped.\n   */\n  get termination_condition_(): Promise<\n    'max_iter' | 'no_change' | 'all_labeled'\n  > {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before accessing termination_condition_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelfTrainingClassifier_termination_condition_ = bridgeSelfTrainingClassifier[${this.id}].termination_condition_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelfTrainingClassifier_termination_condition_.tolist() if hasattr(attr_SelfTrainingClassifier_termination_condition_, 'tolist') else attr_SelfTrainingClassifier_termination_condition_`\n    })()\n  }\n}\n\nexport interface SelfTrainingClassifierOptions {\n  /**\n    An estimator object implementing fit and predict_proba. Invoking the fit method will fit a clone of the passed estimator, which will be stored in the base_estimator_ attribute.\n   */\n  base_estimator?: any\n\n  /**\n    The decision threshold for use with criterion='threshold'. Should be in [0, 1). When using the 'threshold' criterion, a well calibrated classifier should be used.\n\n    @defaultValue `0.75`\n   */\n  threshold?: number\n\n  /**\n    The selection criterion used to select which labels to add to the training set. If 'threshold', pseudo-labels with prediction probabilities above threshold are added to the dataset. If 'k_best', the k_best pseudo-labels with highest prediction probabilities are added to the dataset. When using the ‘threshold’ criterion, a well calibrated classifier should be used.\n\n    @defaultValue `'threshold'`\n   */\n  criterion?: 'threshold' | 'k_best'\n\n  /**\n    The amount of samples to add in each iteration. Only used when criterion='k_best'.\n\n    @defaultValue `10`\n   */\n  k_best?: number\n\n  /**\n    Maximum number of iterations allowed. Should be greater than or equal to 0. If it is None, the classifier will continue to predict labels until no new pseudo-labels are added, or all unlabeled samples have been labeled.\n\n    @defaultValue `10`\n   */\n  max_iter?: number\n\n  /**\n    Enable verbose output.\n\n    @defaultValue `false`\n   */\n  verbose?: boolean\n}\n\nexport interface SelfTrainingClassifierDecisionFunctionOptions {\n  /**\n    Array representing the data.\n   */\n  X?: ArrayLike | SparseMatrix[]\n}\n\nexport interface SelfTrainingClassifierFitOptions {\n  /**\n    Array representing the data.\n   */\n  X?: ArrayLike | SparseMatrix[]\n\n  /**\n    Array representing the labels. Unlabeled samples should have the label -1.\n   */\n  y?: ArrayLike | SparseMatrix\n}\n\nexport interface SelfTrainingClassifierPredictOptions {\n  /**\n    Array representing the data.\n   */\n  X?: ArrayLike | SparseMatrix[]\n}\n\nexport interface SelfTrainingClassifierPredictLogProbaOptions {\n  /**\n    Array representing the data.\n   */\n  X?: ArrayLike | SparseMatrix[]\n}\n\nexport interface SelfTrainingClassifierPredictProbaOptions {\n  /**\n    Array representing the data.\n   */\n  X?: ArrayLike | SparseMatrix[]\n}\n\nexport interface SelfTrainingClassifierScoreOptions {\n  /**\n    Array representing the data.\n   */\n  X?: ArrayLike | SparseMatrix[]\n\n  /**\n    Array representing the labels.\n   */\n  y?: ArrayLike\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Label Propagation classifier.\n\n  @see https://scikit-learn.org/stable/modules/generated/sklearn.semi_supervised.LabelPropagation.html\n */\nexport class LabelPropagation {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: LabelPropagationOptions) {\n    this.id = `LabelPropagation${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('LabelPropagation.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.semi_supervised import LabelPropagation\ntry: bridgeLabelPropagation\nexcept NameError: bridgeLabelPropagation = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_LabelPropagation = {'kernel': ${\n      this.opts['kernel'] ?? undefined\n    }, 'gamma': ${this.opts['gamma'] ?? undefined}, 'n_neighbors': ${\n      this.opts['n_neighbors'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}}\n\nctor_LabelPropagation = {k: v for k, v in ctor_LabelPropagation.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeLabelPropagation[${this.id}] = LabelPropagation(**ctor_LabelPropagation)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeLabelPropagation[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit a semi-supervised label propagation model to X.\n   */\n  async fit(opts: LabelPropagationFitOptions): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelPropagation must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelPropagation_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_LabelPropagation_fit = {k: v for k, v in pms_LabelPropagation_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelPropagation_fit = bridgeLabelPropagation[${this.id}].fit(**pms_LabelPropagation_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelPropagation_fit.tolist() if hasattr(res_LabelPropagation_fit, 'tolist') else res_LabelPropagation_fit`\n  }\n\n  /**\n    Perform inductive inference across the model.\n   */\n  async predict(opts: LabelPropagationPredictOptions): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelPropagation must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelPropagation_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_LabelPropagation_predict = {k: v for k, v in pms_LabelPropagation_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelPropagation_predict = bridgeLabelPropagation[${this.id}].predict(**pms_LabelPropagation_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelPropagation_predict.tolist() if hasattr(res_LabelPropagation_predict, 'tolist') else res_LabelPropagation_predict`\n  }\n\n  /**\n    Predict probability for each possible outcome.\n\n    Compute the probability estimates for each single sample in X and each possible outcome seen during training (categorical distribution).\n   */\n  async predict_proba(\n    opts: LabelPropagationPredictProbaOptions\n  ): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelPropagation must call init() before predict_proba()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelPropagation_predict_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_LabelPropagation_predict_proba = {k: v for k, v in pms_LabelPropagation_predict_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelPropagation_predict_proba = bridgeLabelPropagation[${this.id}].predict_proba(**pms_LabelPropagation_predict_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelPropagation_predict_proba.tolist() if hasattr(res_LabelPropagation_predict_proba, 'tolist') else res_LabelPropagation_predict_proba`\n  }\n\n  /**\n    Return the mean accuracy on the given test data and labels.\n\n    In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.\n   */\n  async score(opts: LabelPropagationScoreOptions): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelPropagation must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelPropagation_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_LabelPropagation_score = {k: v for k, v in pms_LabelPropagation_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelPropagation_score = bridgeLabelPropagation[${this.id}].score(**pms_LabelPropagation_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelPropagation_score.tolist() if hasattr(res_LabelPropagation_score, 'tolist') else res_LabelPropagation_score`\n  }\n\n  /**\n    Input array.\n   */\n  get X_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelPropagation must call init() before accessing X_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelPropagation_X_ = bridgeLabelPropagation[${this.id}].X_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelPropagation_X_.tolist() if hasattr(attr_LabelPropagation_X_, 'tolist') else attr_LabelPropagation_X_`\n    })()\n  }\n\n  /**\n    The distinct labels used in classifying instances.\n   */\n  get classes_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelPropagation must call init() before accessing classes_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelPropagation_classes_ = bridgeLabelPropagation[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelPropagation_classes_.tolist() if hasattr(attr_LabelPropagation_classes_, 'tolist') else attr_LabelPropagation_classes_`\n    })()\n  }\n\n  /**\n    Categorical distribution for each item.\n   */\n  get label_distributions_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelPropagation must call init() before accessing label_distributions_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelPropagation_label_distributions_ = bridgeLabelPropagation[${this.id}].label_distributions_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelPropagation_label_distributions_.tolist() if hasattr(attr_LabelPropagation_label_distributions_, 'tolist') else attr_LabelPropagation_label_distributions_`\n    })()\n  }\n\n  /**\n    Label assigned to each item during fit.\n   */\n  get transduction_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelPropagation must call init() before accessing transduction_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelPropagation_transduction_ = bridgeLabelPropagation[${this.id}].transduction_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelPropagation_transduction_.tolist() if hasattr(attr_LabelPropagation_transduction_, 'tolist') else attr_LabelPropagation_transduction_`\n    })()\n  }\n\n  /**\n    Number of features seen during fit.\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelPropagation must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelPropagation_n_features_in_ = bridgeLabelPropagation[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelPropagation_n_features_in_.tolist() if hasattr(attr_LabelPropagation_n_features_in_, 'tolist') else attr_LabelPropagation_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during fit. Defined only when X has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelPropagation must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelPropagation_feature_names_in_ = bridgeLabelPropagation[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelPropagation_feature_names_in_.tolist() if hasattr(attr_LabelPropagation_feature_names_in_, 'tolist') else attr_LabelPropagation_feature_names_in_`\n    })()\n  }\n\n  /**\n    Number of iterations run.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelPropagation must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelPropagation_n_iter_ = bridgeLabelPropagation[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelPropagation_n_iter_.tolist() if hasattr(attr_LabelPropagation_n_iter_, 'tolist') else attr_LabelPropagation_n_iter_`\n    })()\n  }\n}\n\nexport interface LabelPropagationOptions {\n  /**\n    String identifier for kernel function to use or the kernel function itself. Only ‘rbf’ and ‘knn’ strings are valid inputs. The function passed should take two inputs, each of shape (n_samples, n_features), and return a (n_samples, n_samples) shaped weight matrix.\n\n    @defaultValue `'rbf'`\n   */\n  kernel?: 'knn' | 'rbf'\n\n  /**\n    Parameter for rbf kernel.\n\n    @defaultValue `20`\n   */\n  gamma?: number\n\n  /**\n    Parameter for knn kernel which need to be strictly positive.\n\n    @defaultValue `7`\n   */\n  n_neighbors?: number\n\n  /**\n    Change maximum number of iterations allowed.\n\n    @defaultValue `1000`\n   */\n  max_iter?: number\n\n  /**\n    Convergence tolerance: threshold to consider the system at steady state.\n   */\n  tol?: number\n\n  /**\n    The number of parallel jobs to run. None means 1 unless in a joblib.parallel_backend context. -1 means using all processors. See Glossary for more details.\n   */\n  n_jobs?: number\n}\n\nexport interface LabelPropagationFitOptions {\n  /**\n    Training data, where n_samples is the number of samples and n_features is the number of features.\n   */\n  X?: ArrayLike[]\n\n  /**\n    Target class values with unlabeled points marked as -1. All unlabeled samples will be transductively assigned labels internally, which are stored in transduction_.\n   */\n  y?: ArrayLike\n}\n\nexport interface LabelPropagationPredictOptions {\n  /**\n    The data matrix.\n   */\n  X?: ArrayLike[]\n}\n\nexport interface LabelPropagationPredictProbaOptions {\n  /**\n    The data matrix.\n   */\n  X?: ArrayLike[]\n}\n\nexport interface LabelPropagationScoreOptions {\n  /**\n    Test samples.\n   */\n  X?: ArrayLike[]\n\n  /**\n    True labels for X.\n   */\n  y?: ArrayLike\n\n  /**\n    Sample weights.\n   */\n  sample_weight?: ArrayLike\n}\n"],"mappings":"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","names":["crypto","crypto"]}