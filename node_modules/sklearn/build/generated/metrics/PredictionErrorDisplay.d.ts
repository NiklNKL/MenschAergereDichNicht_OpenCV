import { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types';
/**
  Visualization of the prediction error of a regression model.

  This tool can display “residuals vs predicted” or “actual vs predicted” using scatter plots to qualitatively assess the behavior of a regressor, preferably on held-out data points.

  See the details in the docstrings of from_estimator or from_predictions to create a visualizer. All parameters are stored as attributes.

  For general information regarding scikit-learn visualization tools, read more in the Visualization Guide. For details regarding interpreting these plots, refer to the Model Evaluation Guide.

  @see https://scikit-learn.org/stable/modules/generated/sklearn.metrics.PredictionErrorDisplay.html
 */
export declare class PredictionErrorDisplay {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: PredictionErrorDisplayOptions);
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Plot the prediction error given a regressor and some data.
  
      For general information regarding scikit-learn visualization tools, read more in the Visualization Guide. For details regarding interpreting these plots, refer to the Model Evaluation Guide.
     */
    from_estimator(opts: PredictionErrorDisplayFromEstimatorOptions): Promise<any>;
    /**
      Plot the prediction error given the true and predicted targets.
  
      For general information regarding scikit-learn visualization tools, read more in the Visualization Guide. For details regarding interpreting these plots, refer to the Model Evaluation Guide.
     */
    from_predictions(opts: PredictionErrorDisplayFromPredictionsOptions): Promise<any>;
    /**
      Plot visualization.
  
      Extra keyword arguments will be passed to matplotlib’s plot.
     */
    plot(opts: PredictionErrorDisplayPlotOptions): Promise<any>;
    /**
      Optimal line representing y_true == y_pred. Therefore, it is a diagonal line for kind="predictions" and a horizontal line for kind="residuals".
     */
    get line_(): Promise<any>;
    /**
      Residual lines. If with_errors=False, then it is set to None.
     */
    get errors_lines_(): Promise<any>;
    /**
      Scatter data points.
     */
    get scatter_(): Promise<any>;
    /**
      Axes with the different matplotlib axis.
     */
    get ax_(): Promise<any>;
    /**
      Figure containing the scatter and lines.
     */
    get figure_(): Promise<any>;
}
export interface PredictionErrorDisplayOptions {
    /**
      True values.
     */
    y_true?: NDArray;
    /**
      Prediction values.
     */
    y_pred?: NDArray;
}
export interface PredictionErrorDisplayFromEstimatorOptions {
    /**
      Fitted regressor or a fitted Pipeline in which the last estimator is a regressor.
     */
    estimator?: any;
    /**
      Input values.
     */
    X?: ArrayLike | SparseMatrix[];
    /**
      Target values.
     */
    y?: ArrayLike;
    /**
      The type of plot to draw:
  
      @defaultValue `'residual_vs_predicted'`
     */
    kind?: 'actual_vs_predicted' | 'residual_vs_predicted';
    /**
      Sampling the samples to be shown on the scatter plot. If float, it should be between 0 and 1 and represents the proportion of the original dataset. If int, it represents the number of samples display on the scatter plot. If None, no subsampling will be applied. by default, a 1000 samples or less will be displayed.
  
      @defaultValue `1`
     */
    subsample?: number;
    /**
      Controls the randomness when subsample is not None. See Glossary for details.
     */
    random_state?: number;
    /**
      Axes object to plot on. If None, a new figure and axes is created.
     */
    ax?: any;
    /**
      Dictionary with keywords passed to the matplotlib.pyplot.scatter call.
     */
    scatter_kwargs?: any;
    /**
      Dictionary with keyword passed to the matplotlib.pyplot.plot call to draw the optimal line.
     */
    line_kwargs?: any;
}
export interface PredictionErrorDisplayFromPredictionsOptions {
    /**
      True target values.
     */
    y_true?: ArrayLike;
    /**
      Predicted target values.
     */
    y_pred?: ArrayLike;
    /**
      The type of plot to draw:
  
      @defaultValue `'residual_vs_predicted'`
     */
    kind?: 'actual_vs_predicted' | 'residual_vs_predicted';
    /**
      Sampling the samples to be shown on the scatter plot. If float, it should be between 0 and 1 and represents the proportion of the original dataset. If int, it represents the number of samples display on the scatter plot. If None, no subsampling will be applied. by default, a 1000 samples or less will be displayed.
  
      @defaultValue `1`
     */
    subsample?: number;
    /**
      Controls the randomness when subsample is not None. See Glossary for details.
     */
    random_state?: number;
    /**
      Axes object to plot on. If None, a new figure and axes is created.
     */
    ax?: any;
    /**
      Dictionary with keywords passed to the matplotlib.pyplot.scatter call.
     */
    scatter_kwargs?: any;
    /**
      Dictionary with keyword passed to the matplotlib.pyplot.plot call to draw the optimal line.
     */
    line_kwargs?: any;
}
export interface PredictionErrorDisplayPlotOptions {
    /**
      Axes object to plot on. If None, a new figure and axes is created.
     */
    ax?: any;
    /**
      The type of plot to draw:
  
      @defaultValue `'residual_vs_predicted'`
     */
    kind?: 'actual_vs_predicted' | 'residual_vs_predicted';
    /**
      Dictionary with keywords passed to the matplotlib.pyplot.scatter call.
     */
    scatter_kwargs?: any;
    /**
      Dictionary with keyword passed to the matplotlib.pyplot.plot call to draw the optimal line.
     */
    line_kwargs?: any;
}
//# sourceMappingURL=PredictionErrorDisplay.d.ts.map