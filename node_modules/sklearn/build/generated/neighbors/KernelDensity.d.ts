import { PythonBridge, NDArray, ArrayLike } from '@/sklearn/types';
/**
  Kernel Density Estimation.

  @see https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KernelDensity.html
 */
export declare class KernelDensity {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: KernelDensityOptions);
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Fit the Kernel Density model on the data.
     */
    fit(opts: KernelDensityFitOptions): Promise<any>;
    /**
      Generate random samples from the model.
  
      Currently, this is implemented only for gaussian and tophat kernels.
     */
    sample(opts: KernelDensitySampleOptions): Promise<ArrayLike[]>;
    /**
      Compute the total log-likelihood under the model.
     */
    score(opts: KernelDensityScoreOptions): Promise<number>;
    /**
      Compute the log-likelihood of each sample under the model.
     */
    score_samples(opts: KernelDensityScoreSamplesOptions): Promise<NDArray>;
    /**
      Number of features seen during fit.
     */
    get n_features_in_(): Promise<number>;
    /**
      The tree algorithm for fast generalized N-point problems.
     */
    get tree_(): Promise<any>;
    /**
      Names of features seen during fit. Defined only when X has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
    /**
      Value of the bandwidth, given directly by the bandwidth parameter or estimated using the ‘scott’ or ‘silverman’ method.
     */
    get bandwidth_(): Promise<number>;
}
export interface KernelDensityOptions {
    /**
      The bandwidth of the kernel. If bandwidth is a float, it defines the bandwidth of the kernel. If bandwidth is a string, one of the estimation methods is implemented.
  
      @defaultValue `1`
     */
    bandwidth?: number | 'scott' | 'silverman';
    /**
      The tree algorithm to use.
  
      @defaultValue `'auto'`
     */
    algorithm?: 'kd_tree' | 'ball_tree' | 'auto';
    /**
      The kernel to use.
  
      @defaultValue `'gaussian'`
     */
    kernel?: 'gaussian' | 'tophat' | 'epanechnikov' | 'exponential' | 'linear' | 'cosine';
    /**
      Metric to use for distance computation. See the documentation of scipy.spatial.distance and the metrics listed in distance_metrics for valid metric values.
  
      Not all metrics are valid with all algorithms: refer to the documentation of BallTree and KDTree. Note that the normalization of the density output is correct only for the Euclidean distance metric.
  
      @defaultValue `'euclidean'`
     */
    metric?: string;
    /**
      The desired absolute tolerance of the result.  A larger tolerance will generally lead to faster execution.
  
      @defaultValue `0`
     */
    atol?: number;
    /**
      The desired relative tolerance of the result.  A larger tolerance will generally lead to faster execution.
  
      @defaultValue `0`
     */
    rtol?: number;
    /**
      If true (default), use a breadth-first approach to the problem. Otherwise use a depth-first approach.
  
      @defaultValue `true`
     */
    breadth_first?: boolean;
    /**
      Specify the leaf size of the underlying tree.  See BallTree or KDTree for details.
  
      @defaultValue `40`
     */
    leaf_size?: number;
    /**
      Additional parameters to be passed to the tree for use with the metric.  For more information, see the documentation of BallTree or KDTree.
     */
    metric_params?: any;
}
export interface KernelDensityFitOptions {
    /**
      List of n_features-dimensional data points.  Each row corresponds to a single data point.
     */
    X?: ArrayLike[];
    /**
      Ignored. This parameter exists only for compatibility with Pipeline.
     */
    y?: any;
    /**
      List of sample weights attached to the data X.
     */
    sample_weight?: ArrayLike;
}
export interface KernelDensitySampleOptions {
    /**
      Number of samples to generate.
  
      @defaultValue `1`
     */
    n_samples?: number;
    /**
      Determines random number generation used to generate random samples. Pass an int for reproducible results across multiple function calls. See Glossary.
     */
    random_state?: number;
}
export interface KernelDensityScoreOptions {
    /**
      List of n_features-dimensional data points.  Each row corresponds to a single data point.
     */
    X?: ArrayLike[];
    /**
      Ignored. This parameter exists only for compatibility with Pipeline.
     */
    y?: any;
}
export interface KernelDensityScoreSamplesOptions {
    /**
      An array of points to query.  Last dimension should match dimension of training data (n_features).
     */
    X?: ArrayLike[];
}
//# sourceMappingURL=KernelDensity.d.ts.map