import { PythonBridge, NDArray, ArrayLike } from '@/sklearn/types';
/**
  Neighborhood Components Analysis.

  Neighborhood Component Analysis (NCA) is a machine learning algorithm for metric learning. It learns a linear transformation in a supervised fashion to improve the classification accuracy of a stochastic nearest neighbors rule in the transformed space.

  @see https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.NeighborhoodComponentsAnalysis.html
 */
export declare class NeighborhoodComponentsAnalysis {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: NeighborhoodComponentsAnalysisOptions);
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Fit the model according to the given training data.
     */
    fit(opts: NeighborhoodComponentsAnalysisFitOptions): Promise<any>;
    /**
      Fit to data, then transform it.
  
      Fits transformer to X and y with optional parameters fit_params and returns a transformed version of X.
     */
    fit_transform(opts: NeighborhoodComponentsAnalysisFitTransformOptions): Promise<any[]>;
    /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: ["class_name0", "class_name1", "class_name2"].
     */
    get_feature_names_out(opts: NeighborhoodComponentsAnalysisGetFeatureNamesOutOptions): Promise<any>;
    /**
      Set output container.
  
      See Introducing the set_output API for an example on how to use the API.
     */
    set_output(opts: NeighborhoodComponentsAnalysisSetOutputOptions): Promise<any>;
    /**
      Apply the learned transformation to the given data.
     */
    transform(opts: NeighborhoodComponentsAnalysisTransformOptions): Promise<any>;
    /**
      The linear transformation learned during fitting.
     */
    get components_(): Promise<NDArray[]>;
    /**
      Number of features seen during fit.
     */
    get n_features_in_(): Promise<number>;
    /**
      Counts the number of iterations performed by the optimizer.
     */
    get n_iter_(): Promise<number>;
    /**
      Pseudo random number generator object used during initialization.
     */
    get random_state_(): Promise<any>;
    /**
      Names of features seen during fit. Defined only when X has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
}
export interface NeighborhoodComponentsAnalysisOptions {
    /**
      Preferred dimensionality of the projected space. If None it will be set to n_features.
     */
    n_components?: number;
    /**
      Initialization of the linear transformation. Possible options are 'auto', 'pca', 'lda', 'identity', 'random', and a numpy array of shape (n_features_a, n_features_b).
  
      @defaultValue `'auto'`
     */
    init?: 'auto' | 'pca' | 'lda' | 'identity' | 'random' | NDArray[];
    /**
      If True and fit has been called before, the solution of the previous call to fit is used as the initial linear transformation (n_components and init will be ignored).
  
      @defaultValue `false`
     */
    warm_start?: boolean;
    /**
      Maximum number of iterations in the optimization.
  
      @defaultValue `50`
     */
    max_iter?: number;
    /**
      Convergence tolerance for the optimization.
  
      @defaultValue `0.00001`
     */
    tol?: number;
    /**
      If not None, this function is called after every iteration of the optimizer, taking as arguments the current solution (flattened transformation matrix) and the number of iterations. This might be useful in case one wants to examine or store the transformation found after each iteration.
     */
    callback?: any;
    /**
      If 0, no progress messages will be printed. If 1, progress messages will be printed to stdout. If > 1, progress messages will be printed and the disp parameter of scipy.optimize.minimize will be set to verbose - 2.
  
      @defaultValue `0`
     */
    verbose?: number;
    /**
      A pseudo random number generator object or a seed for it if int. If init='random', random_state is used to initialize the random transformation. If init='pca', random_state is passed as an argument to PCA when initializing the transformation. Pass an int for reproducible results across multiple function calls. See Glossary.
     */
    random_state?: number;
}
export interface NeighborhoodComponentsAnalysisFitOptions {
    /**
      The training samples.
     */
    X?: ArrayLike[];
    /**
      The corresponding training labels.
     */
    y?: ArrayLike;
}
export interface NeighborhoodComponentsAnalysisFitTransformOptions {
    /**
      Input samples.
     */
    X?: ArrayLike[];
    /**
      Target values (None for unsupervised transformations).
     */
    y?: ArrayLike;
    /**
      Additional fit parameters.
     */
    fit_params?: any;
}
export interface NeighborhoodComponentsAnalysisGetFeatureNamesOutOptions {
    /**
      Only used to validate feature names with the names seen in fit.
     */
    input_features?: any;
}
export interface NeighborhoodComponentsAnalysisSetOutputOptions {
    /**
      Configure output of transform and fit_transform.
     */
    transform?: 'default' | 'pandas';
}
export interface NeighborhoodComponentsAnalysisTransformOptions {
    /**
      Data samples.
     */
    X?: ArrayLike[];
}
//# sourceMappingURL=NeighborhoodComponentsAnalysis.d.ts.map