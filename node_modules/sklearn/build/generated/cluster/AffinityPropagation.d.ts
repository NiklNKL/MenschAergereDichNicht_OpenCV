import { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types';
/**
  Perform Affinity Propagation Clustering of data.

  @see https://scikit-learn.org/stable/modules/generated/sklearn.cluster.AffinityPropagation.html
 */
export declare class AffinityPropagation {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: AffinityPropagationOptions);
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Fit the clustering from features, or affinity matrix.
     */
    fit(opts: AffinityPropagationFitOptions): Promise<any>;
    /**
      Fit clustering from features/affinity matrix; return cluster labels.
     */
    fit_predict(opts: AffinityPropagationFitPredictOptions): Promise<NDArray>;
    /**
      Predict the closest cluster each sample in X belongs to.
     */
    predict(opts: AffinityPropagationPredictOptions): Promise<NDArray>;
    /**
      Indices of cluster centers.
     */
    get cluster_centers_indices_(): Promise<NDArray>;
    /**
      Cluster centers (if affinity != precomputed).
     */
    get cluster_centers_(): Promise<NDArray[]>;
    /**
      Labels of each point.
     */
    get labels_(): Promise<NDArray>;
    /**
      Stores the affinity matrix used in fit.
     */
    get affinity_matrix_(): Promise<NDArray[]>;
    /**
      Number of iterations taken to converge.
     */
    get n_iter_(): Promise<number>;
    /**
      Number of features seen during fit.
     */
    get n_features_in_(): Promise<number>;
    /**
      Names of features seen during fit. Defined only when X has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
}
export interface AffinityPropagationOptions {
    /**
      Damping factor in the range [0.5, 1.0) is the extent to which the current value is maintained relative to incoming values (weighted 1 - damping). This in order to avoid numerical oscillations when updating these values (messages).
  
      @defaultValue `0.5`
     */
    damping?: number;
    /**
      Maximum number of iterations.
  
      @defaultValue `200`
     */
    max_iter?: number;
    /**
      Number of iterations with no change in the number of estimated clusters that stops the convergence.
  
      @defaultValue `15`
     */
    convergence_iter?: number;
    /**
      Make a copy of input data.
  
      @defaultValue `true`
     */
    copy?: boolean;
    /**
      Preferences for each point - points with larger values of preferences are more likely to be chosen as exemplars. The number of exemplars, ie of clusters, is influenced by the input preferences value. If the preferences are not passed as arguments, they will be set to the median of the input similarities.
     */
    preference?: ArrayLike | number;
    /**
      Which affinity to use. At the moment ‘precomputed’ and euclidean are supported. ‘euclidean’ uses the negative squared euclidean distance between points.
  
      @defaultValue `'euclidean'`
     */
    affinity?: 'euclidean' | 'precomputed';
    /**
      Whether to be verbose.
  
      @defaultValue `false`
     */
    verbose?: boolean;
    /**
      Pseudo-random number generator to control the starting state. Use an int for reproducible results across function calls. See the Glossary.
     */
    random_state?: number;
}
export interface AffinityPropagationFitOptions {
    /**
      Training instances to cluster, or similarities / affinities between instances if affinity='precomputed'. If a sparse feature matrix is provided, it will be converted into a sparse csr_matrix.
     */
    X?: ArrayLike[];
    /**
      Not used, present here for API consistency by convention.
     */
    y?: any;
}
export interface AffinityPropagationFitPredictOptions {
    /**
      Training instances to cluster, or similarities / affinities between instances if affinity='precomputed'. If a sparse feature matrix is provided, it will be converted into a sparse csr_matrix.
     */
    X?: ArrayLike[];
    /**
      Not used, present here for API consistency by convention.
     */
    y?: any;
}
export interface AffinityPropagationPredictOptions {
    /**
      New data to predict. If a sparse matrix is provided, it will be converted into a sparse csr_matrix.
     */
    X?: ArrayLike | SparseMatrix[];
}
//# sourceMappingURL=AffinityPropagation.d.ts.map