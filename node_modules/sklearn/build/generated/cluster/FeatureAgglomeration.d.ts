import { PythonBridge, NDArray, ArrayLike } from '@/sklearn/types';
/**
  Agglomerate features.

  Recursively merges pair of clusters of features.

  @see https://scikit-learn.org/stable/modules/generated/sklearn.cluster.FeatureAgglomeration.html
 */
export declare class FeatureAgglomeration {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: FeatureAgglomerationOptions);
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Fit the hierarchical clustering on the data.
     */
    fit(opts: FeatureAgglomerationFitOptions): Promise<any>;
    /**
      Fit to data, then transform it.
  
      Fits transformer to X and y with optional parameters fit_params and returns a transformed version of X.
     */
    fit_transform(opts: FeatureAgglomerationFitTransformOptions): Promise<any[]>;
    /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: ["class_name0", "class_name1", "class_name2"].
     */
    get_feature_names_out(opts: FeatureAgglomerationGetFeatureNamesOutOptions): Promise<any>;
    /**
      Inverse the transformation and return a vector of size n_features.
     */
    inverse_transform(opts: FeatureAgglomerationInverseTransformOptions): Promise<NDArray[]>;
    /**
      Set output container.
  
      See Introducing the set_output API for an example on how to use the API.
     */
    set_output(opts: FeatureAgglomerationSetOutputOptions): Promise<any>;
    /**
      Transform a new matrix using the built clustering.
     */
    transform(opts: FeatureAgglomerationTransformOptions): Promise<NDArray[]>;
    /**
      The number of clusters found by the algorithm. If distance_threshold=None, it will be equal to the given n_clusters.
     */
    get n_clusters_(): Promise<number>;
    /**
      Cluster labels for each feature.
     */
    get labels_(): Promise<any>;
    /**
      Number of leaves in the hierarchical tree.
     */
    get n_leaves_(): Promise<number>;
    /**
      The estimated number of connected components in the graph.
     */
    get n_connected_components_(): Promise<number>;
    /**
      Number of features seen during fit.
     */
    get n_features_in_(): Promise<number>;
    /**
      Names of features seen during fit. Defined only when X has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
    /**
      The children of each non-leaf node. Values less than n_features correspond to leaves of the tree which are the original samples. A node i greater than or equal to n_features is a non-leaf node and has children children_[i - n_features]. Alternatively at the i-th iteration, children[i][0] and children[i][1] are merged to form node n_features + i.
     */
    get children_(): Promise<ArrayLike[]>;
    /**
      Distances between nodes in the corresponding place in children_. Only computed if distance_threshold is used or compute_distances is set to True.
     */
    get distances_(): Promise<ArrayLike>;
}
export interface FeatureAgglomerationOptions {
    /**
      The number of clusters to find. It must be None if distance_threshold is not None.
  
      @defaultValue `2`
     */
    n_clusters?: number;
    /**
      The metric to use when calculating distance between instances in a feature array. If metric is a string or callable, it must be one of the options allowed by sklearn.metrics.pairwise_distances for its metric parameter. If linkage is “ward”, only “euclidean” is accepted. If “precomputed”, a distance matrix (instead of a similarity matrix) is needed as input for the fit method.
  
      @defaultValue `'euclidean'`
     */
    affinity?: string;
    /**
      Metric used to compute the linkage. Can be “euclidean”, “l1”, “l2”, “manhattan”, “cosine”, or “precomputed”. If set to None then “euclidean” is used. If linkage is “ward”, only “euclidean” is accepted. If “precomputed”, a distance matrix is needed as input for the fit method.
     */
    metric?: string;
    /**
      Used to cache the output of the computation of the tree. By default, no caching is done. If a string is given, it is the path to the caching directory.
     */
    memory?: string;
    /**
      Connectivity matrix. Defines for each feature the neighboring features following a given structure of the data. This can be a connectivity matrix itself or a callable that transforms the data into a connectivity matrix, such as derived from kneighbors_graph. Default is None, i.e, the hierarchical clustering algorithm is unstructured.
     */
    connectivity?: ArrayLike;
    /**
      Stop early the construction of the tree at n_clusters. This is useful to decrease computation time if the number of clusters is not small compared to the number of features. This option is useful only when specifying a connectivity matrix. Note also that when varying the number of clusters and using caching, it may be advantageous to compute the full tree. It must be True if distance_threshold is not None. By default compute_full_tree is “auto”, which is equivalent to True when distance_threshold is not None or that n_clusters is inferior to the maximum between 100 or 0.02 * n_samples. Otherwise, “auto” is equivalent to False.
  
      @defaultValue `'auto'`
     */
    compute_full_tree?: 'auto' | boolean;
    /**
      Which linkage criterion to use. The linkage criterion determines which distance to use between sets of features. The algorithm will merge the pairs of cluster that minimize this criterion.
  
      @defaultValue `'ward'`
     */
    linkage?: 'ward' | 'complete' | 'average' | 'single';
    /**
      This combines the values of agglomerated features into a single value, and should accept an array of shape [M, N] and the keyword argument axis=1, and reduce it to an array of size [M].
     */
    pooling_func?: any;
    /**
      The linkage distance threshold at or above which clusters will not be merged. If not None, n_clusters must be None and compute_full_tree must be True.
     */
    distance_threshold?: number;
    /**
      Computes distances between clusters even if distance_threshold is not used. This can be used to make dendrogram visualization, but introduces a computational and memory overhead.
  
      @defaultValue `false`
     */
    compute_distances?: boolean;
}
export interface FeatureAgglomerationFitOptions {
    /**
      The data.
     */
    X?: ArrayLike[];
    /**
      Not used, present here for API consistency by convention.
     */
    y?: any;
}
export interface FeatureAgglomerationFitTransformOptions {
    /**
      Input samples.
     */
    X?: ArrayLike[];
    /**
      Target values (None for unsupervised transformations).
     */
    y?: ArrayLike;
    /**
      Additional fit parameters.
     */
    fit_params?: any;
}
export interface FeatureAgglomerationGetFeatureNamesOutOptions {
    /**
      Only used to validate feature names with the names seen in fit.
     */
    input_features?: any;
}
export interface FeatureAgglomerationInverseTransformOptions {
    /**
      The values to be assigned to each cluster of samples.
     */
    Xred?: ArrayLike[];
}
export interface FeatureAgglomerationSetOutputOptions {
    /**
      Configure output of transform and fit_transform.
     */
    transform?: 'default' | 'pandas';
}
export interface FeatureAgglomerationTransformOptions {
    /**
      A M by N array of M observations in N dimensions or a length M array of M one-dimensional observations.
     */
    X?: ArrayLike[];
}
//# sourceMappingURL=FeatureAgglomeration.d.ts.map