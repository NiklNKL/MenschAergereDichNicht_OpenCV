import { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types';
/**
  Apply clustering to a projection of the normalized Laplacian.

  In practice Spectral Clustering is very useful when the structure of the individual clusters is highly non-convex, or more generally when a measure of the center and spread of the cluster is not a suitable description of the complete cluster, such as when clusters are nested circles on the 2D plane.

  If the affinity matrix is the adjacency matrix of a graph, this method can be used to find normalized graph cuts [1], [2].

  When calling fit, an affinity matrix is constructed using either a kernel function such the Gaussian (aka RBF) kernel with Euclidean distance d(X, X):

  @see https://scikit-learn.org/stable/modules/generated/sklearn.cluster.SpectralClustering.html
 */
export declare class SpectralClustering {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: SpectralClusteringOptions);
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Perform spectral clustering from features, or affinity matrix.
     */
    fit(opts: SpectralClusteringFitOptions): Promise<any>;
    /**
      Perform spectral clustering on X and return cluster labels.
     */
    fit_predict(opts: SpectralClusteringFitPredictOptions): Promise<NDArray>;
    /**
      Affinity matrix used for clustering. Available only after calling fit.
     */
    get affinity_matrix_(): Promise<ArrayLike[]>;
    /**
      Labels of each point
     */
    get labels_(): Promise<NDArray>;
    /**
      Number of features seen during fit.
     */
    get n_features_in_(): Promise<number>;
    /**
      Names of features seen during fit. Defined only when X has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
}
export interface SpectralClusteringOptions {
    /**
      The dimension of the projection subspace.
  
      @defaultValue `8`
     */
    n_clusters?: number;
    /**
      The eigenvalue decomposition strategy to use. AMG requires pyamg to be installed. It can be faster on very large, sparse problems, but may also lead to instabilities. If None, then 'arpack' is used. See [4] for more details regarding 'lobpcg'.
     */
    eigen_solver?: 'arpack' | 'lobpcg' | 'amg';
    /**
      Number of eigenvectors to use for the spectral embedding. If None, defaults to n_clusters.
     */
    n_components?: number;
    /**
      A pseudo random number generator used for the initialization of the lobpcg eigenvectors decomposition when eigen_solver == 'amg', and for the K-Means initialization. Use an int to make the results deterministic across calls (See Glossary).
     */
    random_state?: number;
    /**
      Number of time the k-means algorithm will be run with different centroid seeds. The final results will be the best output of n_init consecutive runs in terms of inertia. Only used if assign_labels='kmeans'.
  
      @defaultValue `10`
     */
    n_init?: number;
    /**
      Kernel coefficient for rbf, poly, sigmoid, laplacian and chi2 kernels. Ignored for affinity='nearest_neighbors'.
  
      @defaultValue `1`
     */
    gamma?: number;
    /**
      ‘nearest_neighbors’: construct the affinity matrix by computing a graph of nearest neighbors.
  
      @defaultValue `'rbf'`
     */
    affinity?: string;
    /**
      Number of neighbors to use when constructing the affinity matrix using the nearest neighbors method. Ignored for affinity='rbf'.
  
      @defaultValue `10`
     */
    n_neighbors?: number;
    /**
      Stopping criterion for eigendecomposition of the Laplacian matrix. If eigen_tol="auto" then the passed tolerance will depend on the eigen_solver:
  
      @defaultValue `'auto'`
     */
    eigen_tol?: number;
    /**
      The strategy for assigning labels in the embedding space. There are two ways to assign labels after the Laplacian embedding. k-means is a popular choice, but it can be sensitive to initialization. Discretization is another approach which is less sensitive to random initialization [3]. The cluster_qr method [5] directly extract clusters from eigenvectors in spectral clustering. In contrast to k-means and discretization, cluster_qr has no tuning parameters and runs no iterations, yet may outperform k-means and discretization in terms of both quality and speed.
  
      @defaultValue `'kmeans'`
     */
    assign_labels?: 'kmeans' | 'discretize' | 'cluster_qr';
    /**
      Degree of the polynomial kernel. Ignored by other kernels.
  
      @defaultValue `3`
     */
    degree?: number;
    /**
      Zero coefficient for polynomial and sigmoid kernels. Ignored by other kernels.
  
      @defaultValue `1`
     */
    coef0?: number;
    /**
      Parameters (keyword arguments) and values for kernel passed as callable object. Ignored by other kernels.
     */
    kernel_params?: any;
    /**
      The number of parallel jobs to run when affinity='nearest_neighbors' or affinity='precomputed_nearest_neighbors'. The neighbors search will be done in parallel. None means 1 unless in a joblib.parallel_backend context. -1 means using all processors. See Glossary for more details.
     */
    n_jobs?: number;
    /**
      Verbosity mode.
  
      @defaultValue `false`
     */
    verbose?: boolean;
}
export interface SpectralClusteringFitOptions {
    /**
      Training instances to cluster, similarities / affinities between instances if affinity='precomputed', or distances between instances if affinity='precomputed_nearest_neighbors. If a sparse matrix is provided in a format other than csr_matrix, csc_matrix, or coo_matrix, it will be converted into a sparse csr_matrix.
     */
    X?: ArrayLike | SparseMatrix[];
    /**
      Not used, present here for API consistency by convention.
     */
    y?: any;
}
export interface SpectralClusteringFitPredictOptions {
    /**
      Training instances to cluster, similarities / affinities between instances if affinity='precomputed', or distances between instances if affinity='precomputed_nearest_neighbors. If a sparse matrix is provided in a format other than csr_matrix, csc_matrix, or coo_matrix, it will be converted into a sparse csr_matrix.
     */
    X?: ArrayLike | SparseMatrix[];
    /**
      Not used, present here for API consistency by convention.
     */
    y?: any;
}
//# sourceMappingURL=SpectralClustering.d.ts.map