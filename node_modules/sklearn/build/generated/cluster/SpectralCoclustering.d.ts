import { PythonBridge, NDArray, ArrayLike } from '@/sklearn/types';
/**
  Spectral Co-Clustering algorithm (Dhillon, 2001).

  Clusters rows and columns of an array X to solve the relaxed normalized cut of the bipartite graph created from X as follows: the edge between row vertex i and column vertex j has weight X[i, j].

  The resulting bicluster structure is block-diagonal, since each row and each column belongs to exactly one bicluster.

  Supports sparse matrices, as long as they are nonnegative.

  @see https://scikit-learn.org/stable/modules/generated/sklearn.cluster.SpectralCoclustering.html
 */
export declare class SpectralCoclustering {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: SpectralCoclusteringOptions);
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Create a biclustering for X.
     */
    fit(opts: SpectralCoclusteringFitOptions): Promise<any>;
    /**
      Row and column indices of the i’th bicluster.
  
      Only works if rows_ and columns_ attributes exist.
     */
    get_indices(opts: SpectralCoclusteringGetIndicesOptions): Promise<NDArray>;
    /**
      Shape of the i’th bicluster.
     */
    get_shape(opts: SpectralCoclusteringGetShapeOptions): Promise<number>;
    /**
      Return the submatrix corresponding to bicluster i.
     */
    get_submatrix(opts: SpectralCoclusteringGetSubmatrixOptions): Promise<NDArray[]>;
    /**
      Results of the clustering. rows[i, r] is True if cluster i contains row r. Available only after calling fit.
     */
    get rows_(): Promise<ArrayLike[]>;
    /**
      Results of the clustering, like rows.
     */
    get columns_(): Promise<ArrayLike[]>;
    /**
      The bicluster label of each row.
     */
    get row_labels_(): Promise<ArrayLike>;
    /**
      The bicluster label of each column.
     */
    get column_labels_(): Promise<ArrayLike>;
    /**
      Number of features seen during fit.
     */
    get n_features_in_(): Promise<number>;
    /**
      Names of features seen during fit. Defined only when X has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
}
export interface SpectralCoclusteringOptions {
    /**
      The number of biclusters to find.
  
      @defaultValue `3`
     */
    n_clusters?: number;
    /**
      Selects the algorithm for finding singular vectors. May be ‘randomized’ or ‘arpack’. If ‘randomized’, use sklearn.utils.extmath.randomized_svd, which may be faster for large matrices. If ‘arpack’, use scipy.sparse.linalg.svds, which is more accurate, but possibly slower in some cases.
  
      @defaultValue `'randomized'`
     */
    svd_method?: 'randomized' | 'arpack';
    /**
      Number of vectors to use in calculating the SVD. Corresponds to ncv when svd_method=arpack and n_oversamples when svd_method is ‘randomized`.
     */
    n_svd_vecs?: number;
    /**
      Whether to use mini-batch k-means, which is faster but may get different results.
  
      @defaultValue `false`
     */
    mini_batch?: boolean;
    /**
      Method for initialization of k-means algorithm; defaults to ‘k-means++’.
  
      @defaultValue `'k-means++'`
     */
    init?: NDArray[];
    /**
      Number of random initializations that are tried with the k-means algorithm.
  
      If mini-batch k-means is used, the best initialization is chosen and the algorithm runs once. Otherwise, the algorithm is run for each initialization and the best solution chosen.
  
      @defaultValue `10`
     */
    n_init?: number;
    /**
      Used for randomizing the singular value decomposition and the k-means initialization. Use an int to make the randomness deterministic. See Glossary.
     */
    random_state?: number;
}
export interface SpectralCoclusteringFitOptions {
    /**
      Training data.
     */
    X?: ArrayLike[];
    /**
      Not used, present for API consistency by convention.
     */
    y?: any;
}
export interface SpectralCoclusteringGetIndicesOptions {
    /**
      The index of the cluster.
     */
    i?: number;
}
export interface SpectralCoclusteringGetShapeOptions {
    /**
      The index of the cluster.
     */
    i?: number;
}
export interface SpectralCoclusteringGetSubmatrixOptions {
    /**
      The index of the cluster.
     */
    i?: number;
    /**
      The data.
     */
    data?: ArrayLike[];
}
//# sourceMappingURL=SpectralCoclustering.d.ts.map