import { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types';
/**
  Implements the BIRCH clustering algorithm.

  It is a memory-efficient, online-learning algorithm provided as an alternative to MiniBatchKMeans. It constructs a tree data structure with the cluster centroids being read off the leaf. These can be either the final cluster centroids or can be provided as input to another clustering algorithm such as AgglomerativeClustering.

  @see https://scikit-learn.org/stable/modules/generated/sklearn.cluster.Birch.html
 */
export declare class Birch {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: BirchOptions);
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Build a CF Tree for the input data.
     */
    fit(opts: BirchFitOptions): Promise<any>;
    /**
      Perform clustering on X and returns cluster labels.
     */
    fit_predict(opts: BirchFitPredictOptions): Promise<NDArray>;
    /**
      Fit to data, then transform it.
  
      Fits transformer to X and y with optional parameters fit_params and returns a transformed version of X.
     */
    fit_transform(opts: BirchFitTransformOptions): Promise<any[]>;
    /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: ["class_name0", "class_name1", "class_name2"].
     */
    get_feature_names_out(opts: BirchGetFeatureNamesOutOptions): Promise<any>;
    /**
      Online learning. Prevents rebuilding of CFTree from scratch.
     */
    partial_fit(opts: BirchPartialFitOptions): Promise<any>;
    /**
      Predict data using the centroids_ of subclusters.
  
      Avoid computation of the row norms of X.
     */
    predict(opts: BirchPredictOptions): Promise<any>;
    /**
      Set output container.
  
      See Introducing the set_output API for an example on how to use the API.
     */
    set_output(opts: BirchSetOutputOptions): Promise<any>;
    /**
      Transform X into subcluster centroids dimension.
  
      Each dimension represents the distance from the sample point to each cluster centroid.
     */
    transform(opts: BirchTransformOptions): Promise<ArrayLike | SparseMatrix[]>;
    /**
      Root of the CFTree.
     */
    get root_(): Promise<any>;
    /**
      Start pointer to all the leaves.
     */
    get dummy_leaf_(): Promise<any>;
    /**
      Centroids of all subclusters read directly from the leaves.
     */
    get subcluster_centers_(): Promise<NDArray>;
    /**
      Labels assigned to the centroids of the subclusters after they are clustered globally.
     */
    get subcluster_labels_(): Promise<NDArray>;
    /**
      Array of labels assigned to the input data. if partial_fit is used instead of fit, they are assigned to the last batch of data.
     */
    get labels_(): Promise<NDArray>;
    /**
      Number of features seen during fit.
     */
    get n_features_in_(): Promise<number>;
    /**
      Names of features seen during fit. Defined only when X has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
}
export interface BirchOptions {
    /**
      The radius of the subcluster obtained by merging a new sample and the closest subcluster should be lesser than the threshold. Otherwise a new subcluster is started. Setting this value to be very low promotes splitting and vice-versa.
  
      @defaultValue `0.5`
     */
    threshold?: number;
    /**
      Maximum number of CF subclusters in each node. If a new samples enters such that the number of subclusters exceed the branching_factor then that node is split into two nodes with the subclusters redistributed in each. The parent subcluster of that node is removed and two new subclusters are added as parents of the 2 split nodes.
  
      @defaultValue `50`
     */
    branching_factor?: number;
    /**
      Number of clusters after the final clustering step, which treats the subclusters from the leaves as new samples.
  
      @defaultValue `3`
     */
    n_clusters?: number;
    /**
      Whether or not to compute labels for each fit.
  
      @defaultValue `true`
     */
    compute_labels?: boolean;
    /**
      Whether or not to make a copy of the given data. If set to False, the initial data will be overwritten.
  
      @defaultValue `true`
     */
    copy?: boolean;
}
export interface BirchFitOptions {
    /**
      Input data.
     */
    X?: ArrayLike | SparseMatrix[];
    /**
      Not used, present here for API consistency by convention.
     */
    y?: any;
}
export interface BirchFitPredictOptions {
    /**
      Input data.
     */
    X?: ArrayLike[];
    /**
      Not used, present for API consistency by convention.
     */
    y?: any;
}
export interface BirchFitTransformOptions {
    /**
      Input samples.
     */
    X?: ArrayLike[];
    /**
      Target values (None for unsupervised transformations).
     */
    y?: ArrayLike;
    /**
      Additional fit parameters.
     */
    fit_params?: any;
}
export interface BirchGetFeatureNamesOutOptions {
    /**
      Only used to validate feature names with the names seen in fit.
     */
    input_features?: any;
}
export interface BirchPartialFitOptions {
    /**
      Input data. If X is not provided, only the global clustering step is done.
     */
    X?: ArrayLike | SparseMatrix[];
    /**
      Not used, present here for API consistency by convention.
     */
    y?: any;
}
export interface BirchPredictOptions {
    /**
      Input data.
     */
    X?: ArrayLike | SparseMatrix[];
}
export interface BirchSetOutputOptions {
    /**
      Configure output of transform and fit_transform.
     */
    transform?: 'default' | 'pandas';
}
export interface BirchTransformOptions {
    /**
      Input data.
     */
    X?: ArrayLike | SparseMatrix[];
}
//# sourceMappingURL=Birch.d.ts.map