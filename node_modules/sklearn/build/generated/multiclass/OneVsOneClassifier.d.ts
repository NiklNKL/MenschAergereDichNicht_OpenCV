import { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types';
/**
  One-vs-one multiclass strategy.

  This strategy consists in fitting one classifier per class pair. At prediction time, the class which received the most votes is selected. Since it requires to fit n_classes * (n_classes - 1) / 2 classifiers, this method is usually slower than one-vs-the-rest, due to its O(n_classes^2) complexity. However, this method may be advantageous for algorithms such as kernel algorithms which don’t scale well with n_samples. This is because each individual learning problem only involves a small subset of the data whereas, with one-vs-the-rest, the complete dataset is used n_classes times.

  @see https://scikit-learn.org/stable/modules/generated/sklearn.multiclass.OneVsOneClassifier.html
 */
export declare class OneVsOneClassifier {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: OneVsOneClassifierOptions);
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Decision function for the OneVsOneClassifier.
  
      The decision values for the samples are computed by adding the normalized sum of pair-wise classification confidence levels to the votes in order to disambiguate between the decision values when the votes for all the classes are equal leading to a tie.
     */
    decision_function(opts: OneVsOneClassifierDecisionFunctionOptions): Promise<ArrayLike[]>;
    /**
      Fit underlying estimators.
     */
    fit(opts: OneVsOneClassifierFitOptions): Promise<any>;
    /**
      Partially fit underlying estimators.
  
      Should be used when memory is inefficient to train all data. Chunks of data can be passed in several iteration, where the first call should have an array of all target variables.
     */
    partial_fit(opts: OneVsOneClassifierPartialFitOptions): Promise<any>;
    /**
      Estimate the best class label for each sample in X.
  
      This is implemented as argmax(decision_function(X), axis=1) which will return the label of the class with most votes by estimators predicting the outcome of a decision for each possible class pair.
     */
    predict(opts: OneVsOneClassifierPredictOptions): Promise<any>;
    /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
    score(opts: OneVsOneClassifierScoreOptions): Promise<number>;
    /**
      Estimators used for predictions.
     */
    get estimators_(): Promise<any>;
    /**
      Array containing labels.
     */
    get classes_(): Promise<any>;
    /**
      Indices of samples used when training the estimators. None when estimator’s pairwise tag is False.
     */
    get pairwise_indices_(): Promise<any[]>;
    /**
      Number of features seen during fit.
     */
    get n_features_in_(): Promise<number>;
    /**
      Names of features seen during fit. Defined only when X has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
}
export interface OneVsOneClassifierOptions {
    /**
      A regressor or a classifier that implements fit. When a classifier is passed, decision_function will be used in priority and it will fallback to predict_proba if it is not available. When a regressor is passed, predict is used.
     */
    estimator?: any;
    /**
      The number of jobs to use for the computation: the n_classes * ( n_classes - 1) / 2 OVO problems are computed in parallel.
  
      None means 1 unless in a joblib.parallel_backend context. -1 means using all processors. See Glossary for more details.
     */
    n_jobs?: number;
}
export interface OneVsOneClassifierDecisionFunctionOptions {
    /**
      Input data.
     */
    X?: ArrayLike[];
}
export interface OneVsOneClassifierFitOptions {
    /**
      Data.
     */
    X?: ArrayLike | SparseMatrix[];
    /**
      Multi-class targets.
     */
    y?: ArrayLike;
}
export interface OneVsOneClassifierPartialFitOptions {
    /**
      Data.
     */
    X?: any[];
    /**
      Multi-class targets.
     */
    y?: ArrayLike;
    /**
      Classes across all calls to partial_fit. Can be obtained via np.unique(y_all), where y_all is the target vector of the entire dataset. This argument is only required in the first call of partial_fit and can be omitted in the subsequent calls.
     */
    classes?: any;
}
export interface OneVsOneClassifierPredictOptions {
    /**
      Data.
     */
    X?: ArrayLike | SparseMatrix[];
}
export interface OneVsOneClassifierScoreOptions {
    /**
      Test samples.
     */
    X?: ArrayLike[];
    /**
      True labels for X.
     */
    y?: ArrayLike;
    /**
      Sample weights.
     */
    sample_weight?: ArrayLike;
}
//# sourceMappingURL=OneVsOneClassifier.d.ts.map