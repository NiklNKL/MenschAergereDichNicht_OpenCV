import { PythonBridge } from '@/sklearn/types';
/**
  Container object exposing keys as attributes.

  Bunch objects are sometimes used as an output for functions and methods. They extend dictionaries by enabling values to be accessed by key, bunch["value_key"], or by an attribute, bunch.value_key.

  Examples

  @see https://scikit-learn.org/stable/modules/generated/sklearn.utils.Bunch.html
 */
export declare class Bunch {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: BunchOptions);
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    clear(opts: BunchClearOptions): Promise<any>;
    copy(opts: BunchCopyOptions): Promise<any>;
    /**
      Create a new dictionary with keys from iterable and values set to value.
     */
    fromkeys(opts: BunchFromkeysOptions): Promise<any>;
    /**
      Return the value for key if key is in the dictionary, else default.
     */
    get(opts: BunchGetOptions): Promise<any>;
    items(opts: BunchItemsOptions): Promise<any>;
    keys(opts: BunchKeysOptions): Promise<any>;
    /**
      If key is not found, default is returned if given, otherwise KeyError is raised
     */
    pop(opts: BunchPopOptions): Promise<any>;
    /**
      Remove and return a (key, value) pair as a 2-tuple.
  
      Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty.
     */
    popitem(opts: BunchPopitemOptions): Promise<any>;
    /**
      Insert key with a value of default if key is not in the dictionary.
  
      Return the value for key if key is in the dictionary, else default.
     */
    setdefault(opts: BunchSetdefaultOptions): Promise<any>;
    /**
      If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v In either case, this is followed by: for k in F:  D[k] = F[k]
     */
    update(opts: BunchUpdateOptions): Promise<any>;
    values(opts: BunchValuesOptions): Promise<any>;
}
export interface BunchOptions {
}
export interface BunchClearOptions {
}
export interface BunchCopyOptions {
}
export interface BunchFromkeysOptions {
}
export interface BunchGetOptions {
}
export interface BunchItemsOptions {
}
export interface BunchKeysOptions {
}
export interface BunchPopOptions {
}
export interface BunchPopitemOptions {
}
export interface BunchSetdefaultOptions {
}
export interface BunchUpdateOptions {
}
export interface BunchValuesOptions {
}
//# sourceMappingURL=Bunch.d.ts.map